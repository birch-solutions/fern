// This file was auto-generated by Fern from our API Definition.

package elevenlabs

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/elevenlabs/fern/core"
)

type BodyAddProjectV1ProjectsAddPost struct {
	// The name of the project, used for identification only.
	Name string `json:"name" url:"-"`
	// An optional URL from which we will extract content to initialize the project. If this is set, 'from_url' must be null. If neither 'from_url' or 'from_document' are provided we will initialize the project as blank.
	FromUrl *string `json:"from_url,omitempty" url:"-"`
	// The voice_id that corresponds to the default voice used for new titles.
	DefaultTitleVoiceId string `json:"default_title_voice_id" url:"-"`
	// The voice_id that corresponds to the default voice used for new paragraphs.
	DefaultParagraphVoiceId string `json:"default_paragraph_voice_id" url:"-"`
	// The model_id of the model to be used for this project, you can query GET https://api.elevenlabs.io/v1/models to list all available models.
	DefaultModelId string `json:"default_model_id" url:"-"`
	// Output quality of the generated audio. Must be one of:
	// standard - standard output format, 128kbps with 44.1kHz sample rate.
	// high - high quality output format, 192kbps with 44.1kHz sample rate and major improvements on our side. Using this setting increases the character cost by 20%.
	// ultra - ultra quality output format, 192kbps with 44.1kHz sample rate and highest improvements on our side. Using this setting increases the character cost by 50%.
	// ultra lossless - ultra quality output format, 705.6kbps with 44.1kHz sample rate and highest improvements on our side in a fully lossless format. Using this setting increases the character cost by 100%.
	QualityPreset *string `json:"quality_preset,omitempty" url:"-"`
	// An optional name of the author of the project, this will be added as metadata to the mp3 file on project / chapter download.
	Title *string `json:"title,omitempty" url:"-"`
	// An optional name of the author of the project, this will be added as metadata to the mp3 file on project / chapter download.
	Author *string `json:"author,omitempty" url:"-"`
	// An optional ISBN number of the project you want to create, this will be added as metadata to the mp3 file on project / chapter download.
	IsbnNumber *string `json:"isbn_number,omitempty" url:"-"`
	// [Deprecated] When the project is downloaded, should the returned audio have postprocessing in order to make it compliant with audiobook normalized volume requirements
	AcxVolumeNormalization *bool `json:"acx_volume_normalization,omitempty" url:"-"`
	// When the project is downloaded, should the returned audio have postprocessing in order to make it compliant with audiobook normalized volume requirements
	VolumeNormalization *bool `json:"volume_normalization,omitempty" url:"-"`
	// A list of pronunciation dictionary locators (id, version_id) encoded as a list of JSON strings for pronunciation dictionaries to be applied to the text.  A list of json encoded strings is required as adding projects may occur through formData as opposed to jsonBody
	PronunciationDictionaryLocators []string `json:"pronunciation_dictionary_locators,omitempty" url:"-"`
	// A url that will be called by our service when the project is converted with a json containing the status of the conversion
	CallbackUrl *string `json:"callback_url,omitempty" url:"-"`
}

type BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost struct {
	// Whether to convert the audio to mpeg format.
	ConvertToMpeg *bool `json:"convert_to_mpeg,omitempty" url:"-"`
}

type AddProjectResponseModel struct {
	Project *ProjectResponse `json:"project,omitempty" url:"project,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AddProjectResponseModel) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddProjectResponseModel) UnmarshalJSON(data []byte) error {
	type unmarshaler AddProjectResponseModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddProjectResponseModel(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddProjectResponseModel) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type GetProjectsResponse struct {
	Projects []*ProjectResponse `json:"projects,omitempty" url:"projects,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetProjectsResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetProjectsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetProjectsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetProjectsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetProjectsResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ProjectExtendedResponseModel struct {
	ProjectId               string             `json:"project_id" url:"project_id"`
	Name                    string             `json:"name" url:"name"`
	CreateDateUnix          int                `json:"create_date_unix" url:"create_date_unix"`
	DefaultTitleVoiceId     string             `json:"default_title_voice_id" url:"default_title_voice_id"`
	DefaultParagraphVoiceId string             `json:"default_paragraph_voice_id" url:"default_paragraph_voice_id"`
	DefaultModelId          string             `json:"default_model_id" url:"default_model_id"`
	LastConversionDateUnix  int                `json:"last_conversion_date_unix" url:"last_conversion_date_unix"`
	CanBeDownloaded         bool               `json:"can_be_downloaded" url:"can_be_downloaded"`
	State                   ProjectState       `json:"state" url:"state"`
	Chapters                []*ChapterResponse `json:"chapters,omitempty" url:"chapters,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProjectExtendedResponseModel) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectExtendedResponseModel) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectExtendedResponseModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectExtendedResponseModel(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectExtendedResponseModel) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProjectSnapshotsResponse struct {
	Snapshots []*ProjectSnapshotResponse `json:"snapshots,omitempty" url:"snapshots,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProjectSnapshotsResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProjectSnapshotsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProjectSnapshotsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProjectSnapshotsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProjectSnapshotsResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type UpdatePronunciationDictionariesRequest struct {
	// A list of pronunciation dictionary locators (id, version_id) encoded as a list of JSON strings for pronunciation dictionaries to be applied to the text.  A list of json encoded strings is required as adding projects may occur through formData as opposed to jsonBody
	PronunciationDictionaryLocators []*PronunciationDictionaryVersionLocator `json:"pronunciation_dictionary_locators,omitempty" url:"-"`
}
