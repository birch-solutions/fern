// This file was auto-generated by Fern from our API Definition.

package object

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/inline-types/fern/internal"
)

type PostRootRequest struct {
	Bar *InlineType1 `json:"bar,omitempty" url:"-"`
	Foo string       `json:"foo" url:"-"`
}

type InlineEnum string

const (
	InlineEnumSunny   InlineEnum = "SUNNY"
	InlineEnumCloudy  InlineEnum = "CLOUDY"
	InlineEnumRaining InlineEnum = "RAINING"
	InlineEnumSnowing InlineEnum = "SNOWING"
)

func NewInlineEnumFromString(s string) (InlineEnum, error) {
	switch s {
	case "SUNNY":
		return InlineEnumSunny, nil
	case "CLOUDY":
		return InlineEnumCloudy, nil
	case "RAINING":
		return InlineEnumRaining, nil
	case "SNOWING":
		return InlineEnumSnowing, nil
	}
	var t InlineEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InlineEnum) Ptr() *InlineEnum {
	return &i
}

type InlineType1 struct {
	Foo string             `json:"foo" url:"foo"`
	Bar *NestedInlineType1 `json:"bar,omitempty" url:"bar,omitempty"`

	extraProperties map[string]interface{}
}

func (i *InlineType1) GetFoo() string {
	if i == nil {
		return ""
	}
	return i.Foo
}

func (i *InlineType1) GetBar() *NestedInlineType1 {
	if i == nil {
		return nil
	}
	return i.Bar
}

func (i *InlineType1) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlineType1) UnmarshalJSON(data []byte) error {
	type unmarshaler InlineType1
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlineType1(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlineType1) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlineType2 struct {
	Baz string `json:"baz" url:"baz"`

	extraProperties map[string]interface{}
}

func (i *InlineType2) GetBaz() string {
	if i == nil {
		return ""
	}
	return i.Baz
}

func (i *InlineType2) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlineType2) UnmarshalJSON(data []byte) error {
	type unmarshaler InlineType2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlineType2(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	return nil
}

func (i *InlineType2) String() string {
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedDiscriminatedUnion1 struct {
	Type  string
	Type1 *InlineType1
	Type2 *InlineType2
}

func NewInlinedDiscriminatedUnion1FromType1(value *InlineType1) *InlinedDiscriminatedUnion1 {
	return &InlinedDiscriminatedUnion1{Type: "type1", Type1: value}
}

func NewInlinedDiscriminatedUnion1FromType2(value *InlineType2) *InlinedDiscriminatedUnion1 {
	return &InlinedDiscriminatedUnion1{Type: "type2", Type2: value}
}

func (i *InlinedDiscriminatedUnion1) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InlinedDiscriminatedUnion1) GetType1() *InlineType1 {
	if i == nil {
		return nil
	}
	return i.Type1
}

func (i *InlinedDiscriminatedUnion1) GetType2() *InlineType2 {
	if i == nil {
		return nil
	}
	return i.Type2
}

func (i *InlinedDiscriminatedUnion1) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "type1":
		value := new(InlineType1)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Type1 = value
	case "type2":
		value := new(InlineType2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Type2 = value
	}
	return nil
}

func (i InlinedDiscriminatedUnion1) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "type1":
		return internal.MarshalJSONWithExtraProperty(i.Type1, "type", "type1")
	case "type2":
		return internal.MarshalJSONWithExtraProperty(i.Type2, "type", "type2")
	}
}

type InlinedDiscriminatedUnion1Visitor interface {
	VisitType1(*InlineType1) error
	VisitType2(*InlineType2) error
}

func (i *InlinedDiscriminatedUnion1) Accept(visitor InlinedDiscriminatedUnion1Visitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "type1":
		return visitor.VisitType1(i.Type1)
	case "type2":
		return visitor.VisitType2(i.Type2)
	}
}

type InlinedUndiscriminatedUnion1 struct {
	InlineType1 *InlineType1
	InlineType2 *InlineType2

	typ string
}

func NewInlinedUndiscriminatedUnion1FromInlineType1(value *InlineType1) *InlinedUndiscriminatedUnion1 {
	return &InlinedUndiscriminatedUnion1{typ: "InlineType1", InlineType1: value}
}

func NewInlinedUndiscriminatedUnion1FromInlineType2(value *InlineType2) *InlinedUndiscriminatedUnion1 {
	return &InlinedUndiscriminatedUnion1{typ: "InlineType2", InlineType2: value}
}

func (i *InlinedUndiscriminatedUnion1) GetInlineType1() *InlineType1 {
	if i == nil {
		return nil
	}
	return i.InlineType1
}

func (i *InlinedUndiscriminatedUnion1) GetInlineType2() *InlineType2 {
	if i == nil {
		return nil
	}
	return i.InlineType2
}

func (i *InlinedUndiscriminatedUnion1) UnmarshalJSON(data []byte) error {
	valueInlineType1 := new(InlineType1)
	if err := json.Unmarshal(data, &valueInlineType1); err == nil {
		i.typ = "InlineType1"
		i.InlineType1 = valueInlineType1
		return nil
	}
	valueInlineType2 := new(InlineType2)
	if err := json.Unmarshal(data, &valueInlineType2); err == nil {
		i.typ = "InlineType2"
		i.InlineType2 = valueInlineType2
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InlinedUndiscriminatedUnion1) MarshalJSON() ([]byte, error) {
	if i.typ == "InlineType1" || i.InlineType1 != nil {
		return json.Marshal(i.InlineType1)
	}
	if i.typ == "InlineType2" || i.InlineType2 != nil {
		return json.Marshal(i.InlineType2)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InlinedUndiscriminatedUnion1Visitor interface {
	VisitInlineType1(*InlineType1) error
	VisitInlineType2(*InlineType2) error
}

func (i *InlinedUndiscriminatedUnion1) Accept(visitor InlinedUndiscriminatedUnion1Visitor) error {
	if i.typ == "InlineType1" || i.InlineType1 != nil {
		return visitor.VisitInlineType1(i.InlineType1)
	}
	if i.typ == "InlineType2" || i.InlineType2 != nil {
		return visitor.VisitInlineType2(i.InlineType2)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type NestedInlineType1 struct {
	Foo    string     `json:"foo" url:"foo"`
	Bar    string     `json:"bar" url:"bar"`
	MyEnum InlineEnum `json:"myEnum" url:"myEnum"`

	extraProperties map[string]interface{}
}

func (n *NestedInlineType1) GetFoo() string {
	if n == nil {
		return ""
	}
	return n.Foo
}

func (n *NestedInlineType1) GetBar() string {
	if n == nil {
		return ""
	}
	return n.Bar
}

func (n *NestedInlineType1) GetMyEnum() InlineEnum {
	if n == nil {
		return ""
	}
	return n.MyEnum
}

func (n *NestedInlineType1) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NestedInlineType1) UnmarshalJSON(data []byte) error {
	type unmarshaler NestedInlineType1
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NestedInlineType1(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	return nil
}

func (n *NestedInlineType1) String() string {
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type RootType1 struct {
	Foo string       `json:"foo" url:"foo"`
	Bar *InlineType1 `json:"bar,omitempty" url:"bar,omitempty"`

	extraProperties map[string]interface{}
}

func (r *RootType1) GetFoo() string {
	if r == nil {
		return ""
	}
	return r.Foo
}

func (r *RootType1) GetBar() *InlineType1 {
	if r == nil {
		return nil
	}
	return r.Bar
}

func (r *RootType1) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RootType1) UnmarshalJSON(data []byte) error {
	type unmarshaler RootType1
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RootType1(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	return nil
}

func (r *RootType1) String() string {
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
