// This file was auto-generated by Fern from our API Definition.

package elevenlabs

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/elevenlabs/fern/core"
)

type CreatePreviouslyGenertedVoiceRequest struct {
	// Name to use for the created voice.
	VoiceName string `json:"voice_name" url:"-"`
	// Description to use for the created voice.
	VoiceDescription string `json:"voice_description" url:"-"`
	// The generated_voice_id to create, call POST /v1/voice-generation/generate-voice and fetch the generated_voice_id from the response header if don't have one yet.
	GeneratedVoiceId string `json:"generated_voice_id" url:"-"`
	// Optional, metadata to add to the created voice. Defaults to None.
	Labels map[string]string `json:"labels,omitempty" url:"-"`
}

type GenerateVoiceRequest struct {
	// Category code corresponding to the gender of the generated voice. Possible values: female, male.
	Gender Gender `json:"gender" url:"-"`
	// Category code corresponding to the accent of the generated voice. Possible values: american, british, african, australian, indian.
	Accent string `json:"accent" url:"-"`
	// Category code corresponding to the age of the generated voice. Possible values: young, middle_aged, old.
	Age Age `json:"age" url:"-"`
	// The strength of the accent of the generated voice. Has to be between 0.3 and 2.0.
	AccentStrength float64 `json:"accent_strength" url:"-"`
	// Text to generate, text length has to be between 100 and 1000.
	Text string `json:"text" url:"-"`
}

type Age string

const (
	AgeYoung      Age = "young"
	AgeMiddleAged Age = "middle_aged"
	AgeOld        Age = "old"
)

func NewAgeFromString(s string) (Age, error) {
	switch s {
	case "young":
		return AgeYoung, nil
	case "middle_aged":
		return AgeMiddleAged, nil
	case "old":
		return AgeOld, nil
	}
	var t Age
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a Age) Ptr() *Age {
	return &a
}

type Gender string

const (
	GenderMale   Gender = "male"
	GenderFemale Gender = "female"
)

func NewGenderFromString(s string) (Gender, error) {
	switch s {
	case "male":
		return GenderMale, nil
	case "female":
		return GenderFemale, nil
	}
	var t Gender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g Gender) Ptr() *Gender {
	return &g
}

type VoiceGenerationParameterResponse struct {
	Genders               []*VoiceGenerationParameterOptionResponse `json:"genders,omitempty" url:"genders,omitempty"`
	Accents               []*VoiceGenerationParameterOptionResponse `json:"accents,omitempty" url:"accents,omitempty"`
	Ages                  []*VoiceGenerationParameterOptionResponse `json:"ages,omitempty" url:"ages,omitempty"`
	MinimumCharacters     int                                       `json:"minimum_characters" url:"minimum_characters"`
	MaximumCharacters     int                                       `json:"maximum_characters" url:"maximum_characters"`
	MinimumAccentStrength float64                                   `json:"minimum_accent_strength" url:"minimum_accent_strength"`
	MaximumAccentStrength float64                                   `json:"maximum_accent_strength" url:"maximum_accent_strength"`

	extraProperties map[string]interface{}
}

func (v *VoiceGenerationParameterResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceGenerationParameterResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceGenerationParameterResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceGenerationParameterResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	return nil
}

func (v *VoiceGenerationParameterResponse) String() string {
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
