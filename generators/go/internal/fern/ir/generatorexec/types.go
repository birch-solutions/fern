// This file was auto-generated by Fern from our API Definition.

package generatorexec

import (
	json "encoding/json"
	fmt "fmt"

	core "github.com/fern-api/fern-go/internal/fern/ir/core"
)

type BasicLicense struct {
	Id LicenseId `json:"id" url:"id"`

	extraProperties map[string]interface{}
}

func (b *BasicLicense) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicLicense) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicLicense
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicLicense(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	return nil
}

func (b *BasicLicense) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CustomLicense struct {
	Filename string `json:"filename" url:"filename"`

	extraProperties map[string]interface{}
}

func (c *CustomLicense) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomLicense) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomLicense
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomLicense(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	return nil
}

func (c *CustomLicense) String() string {
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EnvironmentVariable = string

type GeneratorConfig struct {
	DryRun                 bool                   `json:"dryRun" url:"dryRun"`
	IrFilepath             string                 `json:"irFilepath" url:"irFilepath"`
	OriginalReadmeFilepath *string                `json:"originalReadmeFilepath,omitempty" url:"originalReadmeFilepath,omitempty"`
	License                *LicenseConfig         `json:"license,omitempty" url:"license,omitempty"`
	Output                 *GeneratorOutputConfig `json:"output,omitempty" url:"output,omitempty"`
	// Deprecated. Use output.mode instead.
	Publish                  *GeneratorPublishConfig `json:"publish,omitempty" url:"publish,omitempty"`
	WorkspaceName            string                  `json:"workspaceName" url:"workspaceName"`
	Organization             string                  `json:"organization" url:"organization"`
	CustomConfig             interface{}             `json:"customConfig,omitempty" url:"customConfig,omitempty"`
	Environment              *GeneratorEnvironment   `json:"environment,omitempty" url:"environment,omitempty"`
	Whitelabel               bool                    `json:"whitelabel" url:"whitelabel"`
	WriteUnitTests           bool                    `json:"writeUnitTests" url:"writeUnitTests"`
	GeneratePaginatedClients *bool                   `json:"generatePaginatedClients,omitempty" url:"generatePaginatedClients,omitempty"`
	GenerateOauthClients     bool                    `json:"generateOauthClients" url:"generateOauthClients"`

	extraProperties map[string]interface{}
}

func (g *GeneratorConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	return nil
}

func (g *GeneratorConfig) String() string {
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneratorEnvironment struct {
	Type   string
	Local  interface{}
	Remote *RemoteGeneratorEnvironment
}

func NewGeneratorEnvironmentFromLocal(value interface{}) *GeneratorEnvironment {
	return &GeneratorEnvironment{Type: "local", Local: value}
}

func NewGeneratorEnvironmentFromRemote(value *RemoteGeneratorEnvironment) *GeneratorEnvironment {
	return &GeneratorEnvironment{Type: "remote", Remote: value}
}

func (g *GeneratorEnvironment) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", g)
	}
	switch unmarshaler.Type {
	case "local":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Local = value
	case "remote":
		value := new(RemoteGeneratorEnvironment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Remote = value
	}
	return nil
}

func (g GeneratorEnvironment) MarshalJSON() ([]byte, error) {
	switch g.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "local":
		var marshaler = struct {
			Type  string      `json:"_type"`
			Local interface{} `json:"local,omitempty"`
		}{
			Type:  "local",
			Local: g.Local,
		}
		return json.Marshal(marshaler)
	case "remote":
		return core.MarshalJSONWithExtraProperty(g.Remote, "_type", "remote")
	}
}

type GeneratorEnvironmentVisitor interface {
	VisitLocal(interface{}) error
	VisitRemote(*RemoteGeneratorEnvironment) error
}

func (g *GeneratorEnvironment) Accept(visitor GeneratorEnvironmentVisitor) error {
	switch g.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "local":
		return visitor.VisitLocal(g.Local)
	case "remote":
		return visitor.VisitRemote(g.Remote)
	}
}

type GeneratorOutputConfig struct {
	Path                    string              `json:"path" url:"path"`
	SnippetFilepath         *string             `json:"snippetFilepath,omitempty" url:"snippetFilepath,omitempty"`
	SnippetTemplateFilepath *string             `json:"snippetTemplateFilepath,omitempty" url:"snippetTemplateFilepath,omitempty"`
	PublishingMetadata      *PublishingMetadata `json:"publishingMetadata,omitempty" url:"publishingMetadata,omitempty"`
	Mode                    *OutputMode         `json:"mode,omitempty" url:"mode,omitempty"`

	extraProperties map[string]interface{}
}

func (g *GeneratorOutputConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorOutputConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorOutputConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorOutputConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	return nil
}

func (g *GeneratorOutputConfig) String() string {
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneratorPublishConfig struct {
	// Deprecated, use publishTargets instead.
	Registries *GeneratorRegistriesConfig `json:"registries,omitempty" url:"registries,omitempty"`
	// Deprecated, use publishTargets instead.
	RegistriesV2  *GeneratorRegistriesConfigV2 `json:"registriesV2,omitempty" url:"registriesV2,omitempty"`
	PublishTarget *GeneratorPublishTarget      `json:"publishTarget,omitempty" url:"publishTarget,omitempty"`
	Version       string                       `json:"version" url:"version"`

	extraProperties map[string]interface{}
}

func (g *GeneratorPublishConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorPublishConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorPublishConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorPublishConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	return nil
}

func (g *GeneratorPublishConfig) String() string {
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneratorPublishTarget struct {
	Type     string
	Maven    *MavenRegistryConfigV2
	Npm      *NpmRegistryConfigV2
	Pypi     *PypiRegistryConfig
	Postman  *PostmanConfig
	Rubygems *RubyGemsRegistryConfig
	Nuget    *NugetRegistryConfig
}

func NewGeneratorPublishTargetFromMaven(value *MavenRegistryConfigV2) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "maven", Maven: value}
}

func NewGeneratorPublishTargetFromNpm(value *NpmRegistryConfigV2) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "npm", Npm: value}
}

func NewGeneratorPublishTargetFromPypi(value *PypiRegistryConfig) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "pypi", Pypi: value}
}

func NewGeneratorPublishTargetFromPostman(value *PostmanConfig) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "postman", Postman: value}
}

func NewGeneratorPublishTargetFromRubygems(value *RubyGemsRegistryConfig) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "rubygems", Rubygems: value}
}

func NewGeneratorPublishTargetFromNuget(value *NugetRegistryConfig) *GeneratorPublishTarget {
	return &GeneratorPublishTarget{Type: "nuget", Nuget: value}
}

func (g *GeneratorPublishTarget) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "maven":
		value := new(MavenRegistryConfigV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Maven = value
	case "npm":
		value := new(NpmRegistryConfigV2)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Npm = value
	case "pypi":
		value := new(PypiRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Pypi = value
	case "postman":
		value := new(PostmanConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Postman = value
	case "rubygems":
		value := new(RubyGemsRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Rubygems = value
	case "nuget":
		value := new(NugetRegistryConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Nuget = value
	}
	return nil
}

func (g GeneratorPublishTarget) MarshalJSON() ([]byte, error) {
	switch g.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "maven":
		return core.MarshalJSONWithExtraProperty(g.Maven, "type", "maven")
	case "npm":
		return core.MarshalJSONWithExtraProperty(g.Npm, "type", "npm")
	case "pypi":
		return core.MarshalJSONWithExtraProperty(g.Pypi, "type", "pypi")
	case "postman":
		return core.MarshalJSONWithExtraProperty(g.Postman, "type", "postman")
	case "rubygems":
		return core.MarshalJSONWithExtraProperty(g.Rubygems, "type", "rubygems")
	case "nuget":
		return core.MarshalJSONWithExtraProperty(g.Nuget, "type", "nuget")
	}
}

type GeneratorPublishTargetVisitor interface {
	VisitMaven(*MavenRegistryConfigV2) error
	VisitNpm(*NpmRegistryConfigV2) error
	VisitPypi(*PypiRegistryConfig) error
	VisitPostman(*PostmanConfig) error
	VisitRubygems(*RubyGemsRegistryConfig) error
	VisitNuget(*NugetRegistryConfig) error
}

func (g *GeneratorPublishTarget) Accept(visitor GeneratorPublishTargetVisitor) error {
	switch g.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "maven":
		return visitor.VisitMaven(g.Maven)
	case "npm":
		return visitor.VisitNpm(g.Npm)
	case "pypi":
		return visitor.VisitPypi(g.Pypi)
	case "postman":
		return visitor.VisitPostman(g.Postman)
	case "rubygems":
		return visitor.VisitRubygems(g.Rubygems)
	case "nuget":
		return visitor.VisitNuget(g.Nuget)
	}
}

type GeneratorRegistriesConfig struct {
	Maven *MavenRegistryConfig `json:"maven,omitempty" url:"maven,omitempty"`
	Npm   *NpmRegistryConfig   `json:"npm,omitempty" url:"npm,omitempty"`

	extraProperties map[string]interface{}
}

func (g *GeneratorRegistriesConfig) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorRegistriesConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorRegistriesConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorRegistriesConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	return nil
}

func (g *GeneratorRegistriesConfig) String() string {
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GeneratorRegistriesConfigV2 struct {
	Maven    *MavenRegistryConfigV2  `json:"maven,omitempty" url:"maven,omitempty"`
	Npm      *NpmRegistryConfigV2    `json:"npm,omitempty" url:"npm,omitempty"`
	Pypi     *PypiRegistryConfig     `json:"pypi,omitempty" url:"pypi,omitempty"`
	Rubygems *RubyGemsRegistryConfig `json:"rubygems,omitempty" url:"rubygems,omitempty"`
	Nuget    *NugetRegistryConfig    `json:"nuget,omitempty" url:"nuget,omitempty"`

	extraProperties map[string]interface{}
}

func (g *GeneratorRegistriesConfigV2) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeneratorRegistriesConfigV2) UnmarshalJSON(data []byte) error {
	type unmarshaler GeneratorRegistriesConfigV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeneratorRegistriesConfigV2(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	return nil
}

func (g *GeneratorRegistriesConfigV2) String() string {
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GithubOutputMode struct {
	Version string `json:"version" url:"version"`
	// A full repo url (i.e. https://github.com/fern-api/fern)
	RepoUrl string `json:"repoUrl" url:"repoUrl"`
	// The token scoped to installing the repository. If not specified, the generator
	// should NOT attempt to clone the repository.
	InstallationToken *string            `json:"installationToken,omitempty" url:"installationToken,omitempty"`
	PublishInfo       *GithubPublishInfo `json:"publishInfo,omitempty" url:"publishInfo,omitempty"`

	extraProperties map[string]interface{}
}

func (g *GithubOutputMode) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GithubOutputMode) UnmarshalJSON(data []byte) error {
	type unmarshaler GithubOutputMode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GithubOutputMode(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	return nil
}

func (g *GithubOutputMode) String() string {
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GithubPublishInfo struct {
	Type     string
	Npm      *NpmGithubPublishInfo
	Maven    *MavenGithubPublishInfo
	Postman  *PostmanGithubPublishInfo
	Pypi     *PypiGithubPublishInfo
	Rubygems *RubyGemsGithubPublishInfo
	Nuget    *NugetGithubPublishInfo
}

func NewGithubPublishInfoFromNpm(value *NpmGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "npm", Npm: value}
}

func NewGithubPublishInfoFromMaven(value *MavenGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "maven", Maven: value}
}

func NewGithubPublishInfoFromPostman(value *PostmanGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "postman", Postman: value}
}

func NewGithubPublishInfoFromPypi(value *PypiGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "pypi", Pypi: value}
}

func NewGithubPublishInfoFromRubygems(value *RubyGemsGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "rubygems", Rubygems: value}
}

func NewGithubPublishInfoFromNuget(value *NugetGithubPublishInfo) *GithubPublishInfo {
	return &GithubPublishInfo{Type: "nuget", Nuget: value}
}

func (g *GithubPublishInfo) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "npm":
		value := new(NpmGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Npm = value
	case "maven":
		value := new(MavenGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Maven = value
	case "postman":
		value := new(PostmanGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Postman = value
	case "pypi":
		value := new(PypiGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Pypi = value
	case "rubygems":
		value := new(RubyGemsGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Rubygems = value
	case "nuget":
		value := new(NugetGithubPublishInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Nuget = value
	}
	return nil
}

func (g GithubPublishInfo) MarshalJSON() ([]byte, error) {
	switch g.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "npm":
		return core.MarshalJSONWithExtraProperty(g.Npm, "type", "npm")
	case "maven":
		return core.MarshalJSONWithExtraProperty(g.Maven, "type", "maven")
	case "postman":
		return core.MarshalJSONWithExtraProperty(g.Postman, "type", "postman")
	case "pypi":
		return core.MarshalJSONWithExtraProperty(g.Pypi, "type", "pypi")
	case "rubygems":
		return core.MarshalJSONWithExtraProperty(g.Rubygems, "type", "rubygems")
	case "nuget":
		return core.MarshalJSONWithExtraProperty(g.Nuget, "type", "nuget")
	}
}

type GithubPublishInfoVisitor interface {
	VisitNpm(*NpmGithubPublishInfo) error
	VisitMaven(*MavenGithubPublishInfo) error
	VisitPostman(*PostmanGithubPublishInfo) error
	VisitPypi(*PypiGithubPublishInfo) error
	VisitRubygems(*RubyGemsGithubPublishInfo) error
	VisitNuget(*NugetGithubPublishInfo) error
}

func (g *GithubPublishInfo) Accept(visitor GithubPublishInfoVisitor) error {
	switch g.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", g.Type, g)
	case "npm":
		return visitor.VisitNpm(g.Npm)
	case "maven":
		return visitor.VisitMaven(g.Maven)
	case "postman":
		return visitor.VisitPostman(g.Postman)
	case "pypi":
		return visitor.VisitPypi(g.Pypi)
	case "rubygems":
		return visitor.VisitRubygems(g.Rubygems)
	case "nuget":
		return visitor.VisitNuget(g.Nuget)
	}
}

type LicenseConfig struct {
	Type   string
	Basic  *BasicLicense
	Custom *CustomLicense
}

func NewLicenseConfigFromBasic(value *BasicLicense) *LicenseConfig {
	return &LicenseConfig{Type: "basic", Basic: value}
}

func NewLicenseConfigFromCustom(value *CustomLicense) *LicenseConfig {
	return &LicenseConfig{Type: "custom", Custom: value}
}

func (l *LicenseConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", l)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicLicense)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Basic = value
	case "custom":
		value := new(CustomLicense)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		l.Custom = value
	}
	return nil
}

func (l LicenseConfig) MarshalJSON() ([]byte, error) {
	switch l.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "basic":
		return core.MarshalJSONWithExtraProperty(l.Basic, "type", "basic")
	case "custom":
		return core.MarshalJSONWithExtraProperty(l.Custom, "type", "custom")
	}
}

type LicenseConfigVisitor interface {
	VisitBasic(*BasicLicense) error
	VisitCustom(*CustomLicense) error
}

func (l *LicenseConfig) Accept(visitor LicenseConfigVisitor) error {
	switch l.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "basic":
		return visitor.VisitBasic(l.Basic)
	case "custom":
		return visitor.VisitCustom(l.Custom)
	}
}

type LicenseId string

const (
	LicenseIdMit     LicenseId = "MIT"
	LicenseIdApache2 LicenseId = "Apache-2.0"
)

func NewLicenseIdFromString(s string) (LicenseId, error) {
	switch s {
	case "MIT":
		return LicenseIdMit, nil
	case "Apache-2.0":
		return LicenseIdApache2, nil
	}
	var t LicenseId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LicenseId) Ptr() *LicenseId {
	return &l
}

type MavenCentralSignature struct {
	KeyId     string `json:"keyId" url:"keyId"`
	Password  string `json:"password" url:"password"`
	SecretKey string `json:"secretKey" url:"secretKey"`

	extraProperties map[string]interface{}
}

func (m *MavenCentralSignature) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenCentralSignature) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenCentralSignature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenCentralSignature(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	return nil
}

func (m *MavenCentralSignature) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MavenCentralSignatureGithubInfo struct {
	KeyIdEnvironmentVariable     EnvironmentVariable `json:"keyIdEnvironmentVariable" url:"keyIdEnvironmentVariable"`
	PasswordEnvironmentVariable  EnvironmentVariable `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	SecretKeyEnvironmentVariable EnvironmentVariable `json:"secretKeyEnvironmentVariable" url:"secretKeyEnvironmentVariable"`

	extraProperties map[string]interface{}
}

func (m *MavenCentralSignatureGithubInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenCentralSignatureGithubInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenCentralSignatureGithubInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenCentralSignatureGithubInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	return nil
}

func (m *MavenCentralSignatureGithubInfo) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MavenGithubPublishInfo struct {
	RegistryUrl                   string                           `json:"registryUrl" url:"registryUrl"`
	Coordinate                    string                           `json:"coordinate" url:"coordinate"`
	UsernameEnvironmentVariable   EnvironmentVariable              `json:"usernameEnvironmentVariable" url:"usernameEnvironmentVariable"`
	PasswordEnvironmentVariable   EnvironmentVariable              `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	Signature                     *MavenCentralSignatureGithubInfo `json:"signature,omitempty" url:"signature,omitempty"`
	ShouldGeneratePublishWorkflow *bool                            `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MavenGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenGithubPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	return nil
}

func (m *MavenGithubPublishInfo) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MavenRegistryConfig struct {
	RegistryUrl string                 `json:"registryUrl" url:"registryUrl"`
	Username    string                 `json:"username" url:"username"`
	Password    string                 `json:"password" url:"password"`
	Group       string                 `json:"group" url:"group"`
	Signature   *MavenCentralSignature `json:"signature,omitempty" url:"signature,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MavenRegistryConfig) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenRegistryConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	return nil
}

func (m *MavenRegistryConfig) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MavenRegistryConfigV2 struct {
	RegistryUrl string                 `json:"registryUrl" url:"registryUrl"`
	Username    string                 `json:"username" url:"username"`
	Password    string                 `json:"password" url:"password"`
	Coordinate  string                 `json:"coordinate" url:"coordinate"`
	Signature   *MavenCentralSignature `json:"signature,omitempty" url:"signature,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MavenRegistryConfigV2) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MavenRegistryConfigV2) UnmarshalJSON(data []byte) error {
	type unmarshaler MavenRegistryConfigV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MavenRegistryConfigV2(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	return nil
}

func (m *MavenRegistryConfigV2) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NpmGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	TokenEnvironmentVariable      EnvironmentVariable `json:"tokenEnvironmentVariable" url:"tokenEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NpmGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmGithubPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	return nil
}

func (n *NpmGithubPublishInfo) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NpmRegistryConfig struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	Token       string `json:"token" url:"token"`
	Scope       string `json:"scope" url:"scope"`

	extraProperties map[string]interface{}
}

func (n *NpmRegistryConfig) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmRegistryConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	return nil
}

func (n *NpmRegistryConfig) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NpmRegistryConfigV2 struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	Token       string `json:"token" url:"token"`
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
}

func (n *NpmRegistryConfigV2) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NpmRegistryConfigV2) UnmarshalJSON(data []byte) error {
	type unmarshaler NpmRegistryConfigV2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NpmRegistryConfigV2(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	return nil
}

func (n *NpmRegistryConfigV2) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NugetGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	ApiKeyEnvironmentVariable     EnvironmentVariable `json:"apiKeyEnvironmentVariable" url:"apiKeyEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NugetGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NugetGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NugetGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NugetGithubPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	return nil
}

func (n *NugetGithubPublishInfo) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NugetRegistryConfig struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	ApiKey      string `json:"apiKey" url:"apiKey"`
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
}

func (n *NugetRegistryConfig) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NugetRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NugetRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NugetRegistryConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	return nil
}

func (n *NugetRegistryConfig) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type OutputMetadata struct {
	Description *string                 `json:"description,omitempty" url:"description,omitempty"`
	Authors     []*OutputMetadataAuthor `json:"authors,omitempty" url:"authors,omitempty"`

	extraProperties map[string]interface{}
}

func (o *OutputMetadata) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OutputMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler OutputMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OutputMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	return nil
}

func (o *OutputMetadata) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OutputMetadataAuthor struct {
	Name  string `json:"name" url:"name"`
	Email string `json:"email" url:"email"`

	extraProperties map[string]interface{}
}

func (o *OutputMetadataAuthor) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OutputMetadataAuthor) UnmarshalJSON(data []byte) error {
	type unmarshaler OutputMetadataAuthor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OutputMetadataAuthor(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	return nil
}

func (o *OutputMetadataAuthor) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OutputMode struct {
	Type          string
	Publish       *GeneratorPublishConfig
	DownloadFiles interface{}
	Github        *GithubOutputMode
}

func NewOutputModeFromPublish(value *GeneratorPublishConfig) *OutputMode {
	return &OutputMode{Type: "publish", Publish: value}
}

func NewOutputModeFromDownloadFiles(value interface{}) *OutputMode {
	return &OutputMode{Type: "downloadFiles", DownloadFiles: value}
}

func NewOutputModeFromGithub(value *GithubOutputMode) *OutputMode {
	return &OutputMode{Type: "github", Github: value}
}

func (o *OutputMode) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", o)
	}
	switch unmarshaler.Type {
	case "publish":
		value := new(GeneratorPublishConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Publish = value
	case "downloadFiles":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.DownloadFiles = value
	case "github":
		value := new(GithubOutputMode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Github = value
	}
	return nil
}

func (o OutputMode) MarshalJSON() ([]byte, error) {
	switch o.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", o.Type, o)
	case "publish":
		return core.MarshalJSONWithExtraProperty(o.Publish, "type", "publish")
	case "downloadFiles":
		var marshaler = struct {
			Type          string      `json:"type"`
			DownloadFiles interface{} `json:"downloadFiles,omitempty"`
		}{
			Type:          "downloadFiles",
			DownloadFiles: o.DownloadFiles,
		}
		return json.Marshal(marshaler)
	case "github":
		return core.MarshalJSONWithExtraProperty(o.Github, "type", "github")
	}
}

type OutputModeVisitor interface {
	VisitPublish(*GeneratorPublishConfig) error
	VisitDownloadFiles(interface{}) error
	VisitGithub(*GithubOutputMode) error
}

func (o *OutputMode) Accept(visitor OutputModeVisitor) error {
	switch o.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", o.Type, o)
	case "publish":
		return visitor.VisitPublish(o.Publish)
	case "downloadFiles":
		return visitor.VisitDownloadFiles(o.DownloadFiles)
	case "github":
		return visitor.VisitGithub(o.Github)
	}
}

type PostmanConfig struct {
	ApiKey      string `json:"apiKey" url:"apiKey"`
	WorkspaceId string `json:"workspaceId" url:"workspaceId"`

	extraProperties map[string]interface{}
}

func (p *PostmanConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostmanConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PostmanConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostmanConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *PostmanConfig) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostmanGithubPublishInfo struct {
	ApiKeyEnvironmentVariable      EnvironmentVariable `json:"apiKeyEnvironmentVariable" url:"apiKeyEnvironmentVariable"`
	WorkspaceIdEnvironmentVariable EnvironmentVariable `json:"workspaceIdEnvironmentVariable" url:"workspaceIdEnvironmentVariable"`

	extraProperties map[string]interface{}
}

func (p *PostmanGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostmanGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PostmanGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostmanGithubPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *PostmanGithubPublishInfo) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// This should effectively be deprecated in favor of a more specific configuration per-output mode (pypi, maven, etc.).
type PublishingMetadata struct {
	PackageDescription *string `json:"package_description,omitempty" url:"package_description,omitempty"`
	PublisherEmail     *string `json:"publisher_email,omitempty" url:"publisher_email,omitempty"`
	ReferenceUrl       *string `json:"reference_url,omitempty" url:"reference_url,omitempty"`
	PublisherName      *string `json:"publisher_name,omitempty" url:"publisher_name,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PublishingMetadata) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PublishingMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler PublishingMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PublishingMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *PublishingMetadata) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PypiGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	UsernameEnvironmentVariable   EnvironmentVariable `json:"usernameEnvironmentVariable" url:"usernameEnvironmentVariable"`
	PasswordEnvironmentVariable   EnvironmentVariable `json:"passwordEnvironmentVariable" url:"passwordEnvironmentVariable"`
	PypiMetadata                  *PypiMetadata       `json:"pypiMetadata,omitempty" url:"pypiMetadata,omitempty"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PypiGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiGithubPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *PypiGithubPublishInfo) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PypiMetadata struct {
	Description       *string                 `json:"description,omitempty" url:"description,omitempty"`
	Authors           []*OutputMetadataAuthor `json:"authors,omitempty" url:"authors,omitempty"`
	Keywords          []string                `json:"keywords,omitempty" url:"keywords,omitempty"`
	DocumentationLink *string                 `json:"documentationLink,omitempty" url:"documentationLink,omitempty"`
	HomepageLink      *string                 `json:"homepageLink,omitempty" url:"homepageLink,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PypiMetadata) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *PypiMetadata) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PypiRegistryConfig struct {
	RegistryUrl  string        `json:"registryUrl" url:"registryUrl"`
	Username     string        `json:"username" url:"username"`
	Password     string        `json:"password" url:"password"`
	PackageName  string        `json:"packageName" url:"packageName"`
	PypiMetadata *PypiMetadata `json:"pypiMetadata,omitempty" url:"pypiMetadata,omitempty"`

	extraProperties map[string]interface{}
}

func (p *PypiRegistryConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PypiRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PypiRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PypiRegistryConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	return nil
}

func (p *PypiRegistryConfig) String() string {
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RemoteGeneratorEnvironment struct {
	CoordinatorUrl   string `json:"coordinatorUrl" url:"coordinatorUrl"`
	CoordinatorUrlV2 string `json:"coordinatorUrlV2" url:"coordinatorUrlV2"`
	Id               string `json:"id" url:"id"`

	extraProperties map[string]interface{}
}

func (r *RemoteGeneratorEnvironment) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteGeneratorEnvironment) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteGeneratorEnvironment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteGeneratorEnvironment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	return nil
}

func (r *RemoteGeneratorEnvironment) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RubyGemsGithubPublishInfo struct {
	RegistryUrl                   string              `json:"registryUrl" url:"registryUrl"`
	PackageName                   string              `json:"packageName" url:"packageName"`
	ApiKeyEnvironmentVariable     EnvironmentVariable `json:"apiKeyEnvironmentVariable" url:"apiKeyEnvironmentVariable"`
	ShouldGeneratePublishWorkflow *bool               `json:"shouldGeneratePublishWorkflow,omitempty" url:"shouldGeneratePublishWorkflow,omitempty"`

	extraProperties map[string]interface{}
}

func (r *RubyGemsGithubPublishInfo) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyGemsGithubPublishInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyGemsGithubPublishInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyGemsGithubPublishInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	return nil
}

func (r *RubyGemsGithubPublishInfo) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RubyGemsRegistryConfig struct {
	RegistryUrl string `json:"registryUrl" url:"registryUrl"`
	ApiKey      string `json:"apiKey" url:"apiKey"`
	PackageName string `json:"packageName" url:"packageName"`

	extraProperties map[string]interface{}
}

func (r *RubyGemsRegistryConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RubyGemsRegistryConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler RubyGemsRegistryConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RubyGemsRegistryConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	return nil
}

func (r *RubyGemsRegistryConfig) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
