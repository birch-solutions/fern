// This file was auto-generated by Fern from our API Definition.

package dynamic

import (
	json "encoding/json"
	fmt "fmt"

	sdk "github.com/fern-api/fern-go/internal/fern/ir"
	core "github.com/fern-api/fern-go/internal/fern/ir/core"
)

type Auth struct {
	Type   string
	Basic  *BasicAuth
	Bearer *BearerAuth
	Header *HeaderAuth
}

func NewAuthFromBasic(value *BasicAuth) *Auth {
	return &Auth{Type: "basic", Basic: value}
}

func NewAuthFromBearer(value *BearerAuth) *Auth {
	return &Auth{Type: "bearer", Bearer: value}
}

func NewAuthFromHeader(value *HeaderAuth) *Auth {
	return &Auth{Type: "header", Header: value}
}

func (a *Auth) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "bearer":
		value := new(BearerAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "header":
		value := new(HeaderAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	}
	return nil
}

func (a Auth) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "basic":
		return core.MarshalJSONWithExtraProperty(a.Basic, "type", "basic")
	case "bearer":
		return core.MarshalJSONWithExtraProperty(a.Bearer, "type", "bearer")
	case "header":
		return core.MarshalJSONWithExtraProperty(a.Header, "type", "header")
	}
}

type AuthVisitor interface {
	VisitBasic(*BasicAuth) error
	VisitBearer(*BearerAuth) error
	VisitHeader(*HeaderAuth) error
}

func (a *Auth) Accept(visitor AuthVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "basic":
		return visitor.VisitBasic(a.Basic)
	case "bearer":
		return visitor.VisitBearer(a.Bearer)
	case "header":
		return visitor.VisitHeader(a.Header)
	}
}

type AuthValues struct {
	Type   string
	Basic  *BasicAuthValues
	Bearer *BearerAuthValues
	Header *HeaderAuthValues
}

func NewAuthValuesFromBasic(value *BasicAuthValues) *AuthValues {
	return &AuthValues{Type: "basic", Basic: value}
}

func NewAuthValuesFromBearer(value *BearerAuthValues) *AuthValues {
	return &AuthValues{Type: "bearer", Bearer: value}
}

func NewAuthValuesFromHeader(value *HeaderAuthValues) *AuthValues {
	return &AuthValues{Type: "header", Header: value}
}

func (a *AuthValues) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "bearer":
		value := new(BearerAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Bearer = value
	case "header":
		value := new(HeaderAuthValues)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Header = value
	}
	return nil
}

func (a AuthValues) MarshalJSON() ([]byte, error) {
	switch a.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "basic":
		return core.MarshalJSONWithExtraProperty(a.Basic, "type", "basic")
	case "bearer":
		return core.MarshalJSONWithExtraProperty(a.Bearer, "type", "bearer")
	case "header":
		return core.MarshalJSONWithExtraProperty(a.Header, "type", "header")
	}
}

type AuthValuesVisitor interface {
	VisitBasic(*BasicAuthValues) error
	VisitBearer(*BearerAuthValues) error
	VisitHeader(*HeaderAuthValues) error
}

func (a *AuthValues) Accept(visitor AuthValuesVisitor) error {
	switch a.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", a.Type, a)
	case "basic":
		return visitor.VisitBasic(a.Basic)
	case "bearer":
		return visitor.VisitBearer(a.Bearer)
	case "header":
		return visitor.VisitHeader(a.Header)
	}
}

type BasicAuth struct {
	Username *sdk.Name `json:"username,omitempty" url:"username,omitempty"`
	Password *sdk.Name `json:"password,omitempty" url:"password,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BasicAuth) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicAuth(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	return nil
}

func (b *BasicAuth) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BasicAuthValues struct {
	Username string `json:"username" url:"username"`
	Password string `json:"password" url:"password"`

	extraProperties map[string]interface{}
}

func (b *BasicAuthValues) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicAuthValues(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	return nil
}

func (b *BasicAuthValues) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BearerAuth struct {
	Token *sdk.Name `json:"token,omitempty" url:"token,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BearerAuth) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BearerAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler BearerAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BearerAuth(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	return nil
}

func (b *BearerAuth) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BearerAuthValues struct {
	Token string `json:"token" url:"token"`

	extraProperties map[string]interface{}
}

func (b *BearerAuthValues) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BearerAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler BearerAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BearerAuthValues(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	return nil
}

func (b *BearerAuthValues) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type HeaderAuth struct {
	Header *NamedParameter `json:"header,omitempty" url:"header,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HeaderAuth) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeaderAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler HeaderAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HeaderAuth(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	return nil
}

func (h *HeaderAuth) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HeaderAuthValues struct {
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (h *HeaderAuthValues) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HeaderAuthValues) UnmarshalJSON(data []byte) error {
	type unmarshaler HeaderAuthValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HeaderAuthValues(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	return nil
}

func (h *HeaderAuthValues) String() string {
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type Declaration struct {
	FernFilepath *sdk.FernFilepath `json:"fernFilepath,omitempty" url:"fernFilepath,omitempty"`
	Name         *sdk.Name         `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
}

func (d *Declaration) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Declaration) UnmarshalJSON(data []byte) error {
	type unmarshaler Declaration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Declaration(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	return nil
}

func (d *Declaration) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type BodyRequest struct {
	PathParameters []*NamedParameter          `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	Body           *ReferencedRequestBodyType `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
}

func (b *BodyRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BodyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BodyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BodyRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	return nil
}

func (b *BodyRequest) String() string {
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Endpoint struct {
	Auth        *Auth             `json:"auth,omitempty" url:"auth,omitempty"`
	Declaration *Declaration      `json:"declaration,omitempty" url:"declaration,omitempty"`
	Location    *EndpointLocation `json:"location,omitempty" url:"location,omitempty"`
	Request     *Request          `json:"request,omitempty" url:"request,omitempty"`
	Response    *Response         `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
}

func (e *Endpoint) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Endpoint) UnmarshalJSON(data []byte) error {
	type unmarshaler Endpoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Endpoint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	return nil
}

func (e *Endpoint) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Represents the endpoint location (e.g. "POST /users").
type EndpointLocation struct {
	Method sdk.HttpMethod `json:"method" url:"method"`
	Path   string         `json:"path" url:"path"`

	extraProperties map[string]interface{}
}

func (e *EndpointLocation) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointLocation) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointLocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointLocation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	return nil
}

func (e *EndpointLocation) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FileUploadRequestBody struct {
	Properties []*FileUploadRequestBodyProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (f *FileUploadRequestBody) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileUploadRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler FileUploadRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileUploadRequestBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	return nil
}

func (f *FileUploadRequestBody) String() string {
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileUploadRequestBodyProperty struct {
	Type         string
	File         *sdk.NameAndWireValue
	FileArray    *sdk.NameAndWireValue
	BodyProperty *NamedParameter
}

func NewFileUploadRequestBodyPropertyFromFile(value *sdk.NameAndWireValue) *FileUploadRequestBodyProperty {
	return &FileUploadRequestBodyProperty{Type: "file", File: value}
}

func NewFileUploadRequestBodyPropertyFromFileArray(value *sdk.NameAndWireValue) *FileUploadRequestBodyProperty {
	return &FileUploadRequestBodyProperty{Type: "fileArray", FileArray: value}
}

func NewFileUploadRequestBodyPropertyFromBodyProperty(value *NamedParameter) *FileUploadRequestBodyProperty {
	return &FileUploadRequestBodyProperty{Type: "bodyProperty", BodyProperty: value}
}

func (f *FileUploadRequestBodyProperty) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "file":
		value := new(sdk.NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.File = value
	case "fileArray":
		value := new(sdk.NameAndWireValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.FileArray = value
	case "bodyProperty":
		value := new(NamedParameter)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.BodyProperty = value
	}
	return nil
}

func (f FileUploadRequestBodyProperty) MarshalJSON() ([]byte, error) {
	switch f.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return core.MarshalJSONWithExtraProperty(f.File, "type", "file")
	case "fileArray":
		return core.MarshalJSONWithExtraProperty(f.FileArray, "type", "fileArray")
	case "bodyProperty":
		return core.MarshalJSONWithExtraProperty(f.BodyProperty, "type", "bodyProperty")
	}
}

type FileUploadRequestBodyPropertyVisitor interface {
	VisitFile(*sdk.NameAndWireValue) error
	VisitFileArray(*sdk.NameAndWireValue) error
	VisitBodyProperty(*NamedParameter) error
}

func (f *FileUploadRequestBodyProperty) Accept(visitor FileUploadRequestBodyPropertyVisitor) error {
	switch f.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", f.Type, f)
	case "file":
		return visitor.VisitFile(f.File)
	case "fileArray":
		return visitor.VisitFileArray(f.FileArray)
	case "bodyProperty":
		return visitor.VisitBodyProperty(f.BodyProperty)
	}
}

type InlinedRequest struct {
	Declaration     *Declaration        `json:"declaration,omitempty" url:"declaration,omitempty"`
	PathParameters  []*NamedParameter   `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	QueryParameters []*NamedParameter   `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Headers         []*NamedParameter   `json:"headers,omitempty" url:"headers,omitempty"`
	Body            *InlinedRequestBody `json:"body,omitempty" url:"body,omitempty"`

	extraProperties map[string]interface{}
}

func (i *InlinedRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InlinedRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InlinedRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InlinedRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	return nil
}

func (i *InlinedRequest) String() string {
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InlinedRequestBody struct {
	Type       string
	Properties []*NamedParameter
	Referenced *ReferencedRequestBody
	FileUpload *FileUploadRequestBody
}

func NewInlinedRequestBodyFromProperties(value []*NamedParameter) *InlinedRequestBody {
	return &InlinedRequestBody{Type: "properties", Properties: value}
}

func NewInlinedRequestBodyFromReferenced(value *ReferencedRequestBody) *InlinedRequestBody {
	return &InlinedRequestBody{Type: "referenced", Referenced: value}
}

func NewInlinedRequestBodyFromFileUpload(value *FileUploadRequestBody) *InlinedRequestBody {
	return &InlinedRequestBody{Type: "fileUpload", FileUpload: value}
}

func (i *InlinedRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "properties":
		var valueUnmarshaler struct {
			Properties []*NamedParameter `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.Properties = valueUnmarshaler.Properties
	case "referenced":
		value := new(ReferencedRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Referenced = value
	case "fileUpload":
		value := new(FileUploadRequestBody)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.FileUpload = value
	}
	return nil
}

func (i InlinedRequestBody) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "properties":
		var marshaler = struct {
			Type       string            `json:"type"`
			Properties []*NamedParameter `json:"value,omitempty"`
		}{
			Type:       "properties",
			Properties: i.Properties,
		}
		return json.Marshal(marshaler)
	case "referenced":
		return core.MarshalJSONWithExtraProperty(i.Referenced, "type", "referenced")
	case "fileUpload":
		return core.MarshalJSONWithExtraProperty(i.FileUpload, "type", "fileUpload")
	}
}

type InlinedRequestBodyVisitor interface {
	VisitProperties([]*NamedParameter) error
	VisitReferenced(*ReferencedRequestBody) error
	VisitFileUpload(*FileUploadRequestBody) error
}

func (i *InlinedRequestBody) Accept(visitor InlinedRequestBodyVisitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "properties":
		return visitor.VisitProperties(i.Properties)
	case "referenced":
		return visitor.VisitReferenced(i.Referenced)
	case "fileUpload":
		return visitor.VisitFileUpload(i.FileUpload)
	}
}

type ReferencedRequestBody struct {
	BodyKey  *sdk.Name                  `json:"bodyKey,omitempty" url:"bodyKey,omitempty"`
	BodyType *ReferencedRequestBodyType `json:"bodyType,omitempty" url:"bodyType,omitempty"`

	extraProperties map[string]interface{}
}

func (r *ReferencedRequestBody) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReferencedRequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ReferencedRequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReferencedRequestBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	return nil
}

func (r *ReferencedRequestBody) String() string {
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ReferencedRequestBodyType struct {
	Type          string
	Bytes         interface{}
	TypeReference *TypeReference
}

func NewReferencedRequestBodyTypeFromBytes(value interface{}) *ReferencedRequestBodyType {
	return &ReferencedRequestBodyType{Type: "bytes", Bytes: value}
}

func NewReferencedRequestBodyTypeFromTypeReference(value *TypeReference) *ReferencedRequestBodyType {
	return &ReferencedRequestBodyType{Type: "typeReference", TypeReference: value}
}

func (r *ReferencedRequestBodyType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "bytes":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Bytes = value
	case "typeReference":
		var valueUnmarshaler struct {
			TypeReference *TypeReference `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.TypeReference = valueUnmarshaler.TypeReference
	}
	return nil
}

func (r ReferencedRequestBodyType) MarshalJSON() ([]byte, error) {
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "bytes":
		var marshaler = struct {
			Type  string      `json:"type"`
			Bytes interface{} `json:"bytes,omitempty"`
		}{
			Type:  "bytes",
			Bytes: r.Bytes,
		}
		return json.Marshal(marshaler)
	case "typeReference":
		var marshaler = struct {
			Type          string         `json:"type"`
			TypeReference *TypeReference `json:"value,omitempty"`
		}{
			Type:          "typeReference",
			TypeReference: r.TypeReference,
		}
		return json.Marshal(marshaler)
	}
}

type ReferencedRequestBodyTypeVisitor interface {
	VisitBytes(interface{}) error
	VisitTypeReference(*TypeReference) error
}

func (r *ReferencedRequestBodyType) Accept(visitor ReferencedRequestBodyTypeVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "bytes":
		return visitor.VisitBytes(r.Bytes)
	case "typeReference":
		return visitor.VisitTypeReference(r.TypeReference)
	}
}

// Reperesents the request parameters required to call a specific endpoiont.
type Request struct {
	Type    string
	Body    *BodyRequest
	Inlined *InlinedRequest
}

func NewRequestFromBody(value *BodyRequest) *Request {
	return &Request{Type: "body", Body: value}
}

func NewRequestFromInlined(value *InlinedRequest) *Request {
	return &Request{Type: "inlined", Inlined: value}
}

func (r *Request) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "body":
		value := new(BodyRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Body = value
	case "inlined":
		value := new(InlinedRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Inlined = value
	}
	return nil
}

func (r Request) MarshalJSON() ([]byte, error) {
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "body":
		return core.MarshalJSONWithExtraProperty(r.Body, "type", "body")
	case "inlined":
		return core.MarshalJSONWithExtraProperty(r.Inlined, "type", "inlined")
	}
}

type RequestVisitor interface {
	VisitBody(*BodyRequest) error
	VisitInlined(*InlinedRequest) error
}

func (r *Request) Accept(visitor RequestVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "body":
		return visitor.VisitBody(r.Body)
	case "inlined":
		return visitor.VisitInlined(r.Inlined)
	}
}

// Reperesents the response returned by a specific endpoint.
//
// For now, we only support json responses, but this is set up to support a
// variety of other endpoint response types (e.g. file download, pagination,
// streaming, etc).
type Response struct {
	Type string
	Json interface{}
}

func NewResponseFromJson(value interface{}) *Response {
	return &Response{Type: "json", Json: value}
}

func (r *Response) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "json":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Json = value
	}
	return nil
}

func (r Response) MarshalJSON() ([]byte, error) {
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "json":
		var marshaler = struct {
			Type string      `json:"type"`
			Json interface{} `json:"json,omitempty"`
		}{
			Type: "json",
			Json: r.Json,
		}
		return json.Marshal(marshaler)
	}
}

type ResponseVisitor interface {
	VisitJson(interface{}) error
}

func (r *Response) Accept(visitor ResponseVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "json":
		return visitor.VisitJson(r.Json)
	}
}

// This represents the IR required to generate dynamic snippets.
//
// This IR minimizes the space required to generate snippets in a variety
// of environments (e.g. web, offline, etc).
type DynamicIntermediateRepresentation struct {
	// The version of the dynamic IR. This is independent from the verison
	// of the primary IR.
	Types     map[sdk.TypeId]*NamedType    `json:"types,omitempty" url:"types,omitempty"`
	Endpoints map[sdk.EndpointId]*Endpoint `json:"endpoints,omitempty" url:"endpoints,omitempty"`
	// The headers that are required on every request. These headers
	// are typically included in the SDK's client constructor.
	Headers []*NamedParameter `json:"headers,omitempty" url:"headers,omitempty"`
	version string

	extraProperties map[string]interface{}
}

func (d *DynamicIntermediateRepresentation) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DynamicIntermediateRepresentation) Version() string {
	return d.version
}

func (d *DynamicIntermediateRepresentation) UnmarshalJSON(data []byte) error {
	type embed DynamicIntermediateRepresentation
	var unmarshaler = struct {
		embed
		Version string `json:"version"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DynamicIntermediateRepresentation(unmarshaler.embed)
	if unmarshaler.Version != "1.0.0" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", d, "1.0.0", unmarshaler.Version)
	}
	d.version = unmarshaler.Version

	extraProperties, err := core.ExtractExtraProperties(data, *d, "version")
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	return nil
}

func (d *DynamicIntermediateRepresentation) MarshalJSON() ([]byte, error) {
	type embed DynamicIntermediateRepresentation
	var marshaler = struct {
		embed
		Version string `json:"version"`
	}{
		embed:   embed(*d),
		Version: "1.0.0",
	}
	return json.Marshal(marshaler)
}

func (d *DynamicIntermediateRepresentation) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The user-facing request type used to generate a dynamic snippet.
type EndpointSnippetRequest struct {
	Endpoint        *EndpointLocation `json:"endpoint,omitempty" url:"endpoint,omitempty"`
	Auth            *AuthValues       `json:"auth,omitempty" url:"auth,omitempty"`
	PathParameters  *Values           `json:"pathParameters,omitempty" url:"pathParameters,omitempty"`
	QueryParameters *Values           `json:"queryParameters,omitempty" url:"queryParameters,omitempty"`
	Headers         *Values           `json:"headers,omitempty" url:"headers,omitempty"`
	RequestBody     interface{}       `json:"requestBody,omitempty" url:"requestBody,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EndpointSnippetRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointSnippetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointSnippetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointSnippetRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	return nil
}

func (e *EndpointSnippetRequest) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The user-facing response type containing the generated snippet.
//
// If there are any errors, the snippet will still sometimes represent a
// partial and/or valid result. This is useful for rendering a snippet alongside
// error messages the user can use to diagnose and resolve the problem.
type EndpointSnippetResponse struct {
	Snippet string   `json:"snippet" url:"snippet"`
	Errors  []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EndpointSnippetResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndpointSnippetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EndpointSnippetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndpointSnippetResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	return nil
}

func (e *EndpointSnippetResponse) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Error struct {
	Severity ErrorSeverity `json:"severity" url:"severity"`
	Message  string        `json:"message" url:"message"`

	extraProperties map[string]interface{}
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	return nil
}

func (e *Error) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorSeverity string

const (
	ErrorSeverityCritical ErrorSeverity = "CRITICAL"
	ErrorSeverityWarning  ErrorSeverity = "WARNING"
)

func NewErrorSeverityFromString(s string) (ErrorSeverity, error) {
	switch s {
	case "CRITICAL":
		return ErrorSeverityCritical, nil
	case "WARNING":
		return ErrorSeverityWarning, nil
	}
	var t ErrorSeverity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorSeverity) Ptr() *ErrorSeverity {
	return &e
}

// Snippet values are represented as arbitrary key, value
// pairs (i.e. JSON objects). The keys are expected to be
// in the parameter's wire representation. For path parameters,
// the name will match the parameter name.
type Values = map[string]interface{}

type AliasType struct {
	Declaration   *Declaration   `json:"declaration,omitempty" url:"declaration,omitempty"`
	TypeReference *TypeReference `json:"typeReference,omitempty" url:"typeReference,omitempty"`

	extraProperties map[string]interface{}
}

func (a *AliasType) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AliasType) UnmarshalJSON(data []byte) error {
	type unmarshaler AliasType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AliasType(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	return nil
}

func (a *AliasType) String() string {
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type DiscriminatedUnionType struct {
	Declaration  *Declaration          `json:"declaration,omitempty" url:"declaration,omitempty"`
	Discriminant *sdk.NameAndWireValue `json:"discriminant,omitempty" url:"discriminant,omitempty"`
	// Map from the discriminant value (e.g. "user") to the type (e.g. User).
	Types map[string]*SingleDiscriminatedUnionType `json:"types,omitempty" url:"types,omitempty"`

	extraProperties map[string]interface{}
}

func (d *DiscriminatedUnionType) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler DiscriminatedUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DiscriminatedUnionType(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	return nil
}

func (d *DiscriminatedUnionType) String() string {
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EnumType struct {
	Declaration *Declaration            `json:"declaration,omitempty" url:"declaration,omitempty"`
	Values      []*sdk.NameAndWireValue `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
}

func (e *EnumType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnumType) UnmarshalJSON(data []byte) error {
	type unmarshaler EnumType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnumType(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	return nil
}

func (e *EnumType) String() string {
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type LiteralType struct {
	Type    string
	Boolean bool
	String  string
}

func NewLiteralTypeFromBoolean(value bool) *LiteralType {
	return &LiteralType{Type: "boolean", Boolean: value}
}

func NewLiteralTypeFromString(value string) *LiteralType {
	return &LiteralType{Type: "string", String: value}
}

func (l *LiteralType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	l.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", l)
	}
	switch unmarshaler.Type {
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.Boolean = valueUnmarshaler.Boolean
	case "string":
		var valueUnmarshaler struct {
			String string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		l.String = valueUnmarshaler.String
	}
	return nil
}

func (l LiteralType) MarshalJSON() ([]byte, error) {
	switch l.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "boolean":
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"value"`
		}{
			Type:    "boolean",
			Boolean: l.Boolean,
		}
		return json.Marshal(marshaler)
	case "string":
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"value"`
		}{
			Type:   "string",
			String: l.String,
		}
		return json.Marshal(marshaler)
	}
}

type LiteralTypeVisitor interface {
	VisitBoolean(bool) error
	VisitString(string) error
}

func (l *LiteralType) Accept(visitor LiteralTypeVisitor) error {
	switch l.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", l.Type, l)
	case "boolean":
		return visitor.VisitBoolean(l.Boolean)
	case "string":
		return visitor.VisitString(l.String)
	}
}

type MapType struct {
	Key   *TypeReference `json:"key,omitempty" url:"key,omitempty"`
	Value *TypeReference `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
}

func (m *MapType) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MapType) UnmarshalJSON(data []byte) error {
	type unmarshaler MapType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MapType(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	return nil
}

func (m *MapType) String() string {
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NamedParameter struct {
	Name          *sdk.NameAndWireValue `json:"name,omitempty" url:"name,omitempty"`
	TypeReference *TypeReference        `json:"typeReference,omitempty" url:"typeReference,omitempty"`

	extraProperties map[string]interface{}
}

func (n *NamedParameter) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NamedParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler NamedParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamedParameter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	return nil
}

func (n *NamedParameter) String() string {
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Represents the type of a parameter that can be used to generate a dynamic type.
type NamedType struct {
	Type                 string
	Alias                *AliasType
	Enum                 *EnumType
	Object               *ObjectType
	DiscriminatedUnion   *DiscriminatedUnionType
	UndiscriminatedUnion *UndiscriminatedUnionType
}

func NewNamedTypeFromAlias(value *AliasType) *NamedType {
	return &NamedType{Type: "alias", Alias: value}
}

func NewNamedTypeFromEnum(value *EnumType) *NamedType {
	return &NamedType{Type: "enum", Enum: value}
}

func NewNamedTypeFromObject(value *ObjectType) *NamedType {
	return &NamedType{Type: "object", Object: value}
}

func NewNamedTypeFromDiscriminatedUnion(value *DiscriminatedUnionType) *NamedType {
	return &NamedType{Type: "discriminatedUnion", DiscriminatedUnion: value}
}

func NewNamedTypeFromUndiscriminatedUnion(value *UndiscriminatedUnionType) *NamedType {
	return &NamedType{Type: "undiscriminatedUnion", UndiscriminatedUnion: value}
}

func (n *NamedType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "alias":
		value := new(AliasType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Alias = value
	case "enum":
		value := new(EnumType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Enum = value
	case "object":
		value := new(ObjectType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Object = value
	case "discriminatedUnion":
		value := new(DiscriminatedUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.DiscriminatedUnion = value
	case "undiscriminatedUnion":
		value := new(UndiscriminatedUnionType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.UndiscriminatedUnion = value
	}
	return nil
}

func (n NamedType) MarshalJSON() ([]byte, error) {
	switch n.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.Type, n)
	case "alias":
		return core.MarshalJSONWithExtraProperty(n.Alias, "type", "alias")
	case "enum":
		return core.MarshalJSONWithExtraProperty(n.Enum, "type", "enum")
	case "object":
		return core.MarshalJSONWithExtraProperty(n.Object, "type", "object")
	case "discriminatedUnion":
		return core.MarshalJSONWithExtraProperty(n.DiscriminatedUnion, "type", "discriminatedUnion")
	case "undiscriminatedUnion":
		return core.MarshalJSONWithExtraProperty(n.UndiscriminatedUnion, "type", "undiscriminatedUnion")
	}
}

type NamedTypeVisitor interface {
	VisitAlias(*AliasType) error
	VisitEnum(*EnumType) error
	VisitObject(*ObjectType) error
	VisitDiscriminatedUnion(*DiscriminatedUnionType) error
	VisitUndiscriminatedUnion(*UndiscriminatedUnionType) error
}

func (n *NamedType) Accept(visitor NamedTypeVisitor) error {
	switch n.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", n.Type, n)
	case "alias":
		return visitor.VisitAlias(n.Alias)
	case "enum":
		return visitor.VisitEnum(n.Enum)
	case "object":
		return visitor.VisitObject(n.Object)
	case "discriminatedUnion":
		return visitor.VisitDiscriminatedUnion(n.DiscriminatedUnion)
	case "undiscriminatedUnion":
		return visitor.VisitUndiscriminatedUnion(n.UndiscriminatedUnion)
	}
}

type ObjectType struct {
	Declaration *Declaration      `json:"declaration,omitempty" url:"declaration,omitempty"`
	Properties  []*NamedParameter `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (o *ObjectType) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObjectType) UnmarshalJSON(data []byte) error {
	type unmarshaler ObjectType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObjectType(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	return nil
}

func (o *ObjectType) String() string {
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type SingleDiscriminatedUnionType struct {
	Type                   string
	SamePropertiesAsObject *SingleDiscriminatedUnionTypeObject
	SingleProperty         *SingleDiscriminatedUnionTypeSingleProperty
	NoProperties           *SingleDiscriminatedUnionTypeNoProperties
}

func NewSingleDiscriminatedUnionTypeFromSamePropertiesAsObject(value *SingleDiscriminatedUnionTypeObject) *SingleDiscriminatedUnionType {
	return &SingleDiscriminatedUnionType{Type: "samePropertiesAsObject", SamePropertiesAsObject: value}
}

func NewSingleDiscriminatedUnionTypeFromSingleProperty(value *SingleDiscriminatedUnionTypeSingleProperty) *SingleDiscriminatedUnionType {
	return &SingleDiscriminatedUnionType{Type: "singleProperty", SingleProperty: value}
}

func NewSingleDiscriminatedUnionTypeFromNoProperties(value *SingleDiscriminatedUnionTypeNoProperties) *SingleDiscriminatedUnionType {
	return &SingleDiscriminatedUnionType{Type: "noProperties", NoProperties: value}
}

func (s *SingleDiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "samePropertiesAsObject":
		value := new(SingleDiscriminatedUnionTypeObject)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SamePropertiesAsObject = value
	case "singleProperty":
		value := new(SingleDiscriminatedUnionTypeSingleProperty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SingleProperty = value
	case "noProperties":
		value := new(SingleDiscriminatedUnionTypeNoProperties)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.NoProperties = value
	}
	return nil
}

func (s SingleDiscriminatedUnionType) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "samePropertiesAsObject":
		return core.MarshalJSONWithExtraProperty(s.SamePropertiesAsObject, "type", "samePropertiesAsObject")
	case "singleProperty":
		return core.MarshalJSONWithExtraProperty(s.SingleProperty, "type", "singleProperty")
	case "noProperties":
		return core.MarshalJSONWithExtraProperty(s.NoProperties, "type", "noProperties")
	}
}

type SingleDiscriminatedUnionTypeVisitor interface {
	VisitSamePropertiesAsObject(*SingleDiscriminatedUnionTypeObject) error
	VisitSingleProperty(*SingleDiscriminatedUnionTypeSingleProperty) error
	VisitNoProperties(*SingleDiscriminatedUnionTypeNoProperties) error
}

func (s *SingleDiscriminatedUnionType) Accept(visitor SingleDiscriminatedUnionTypeVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "samePropertiesAsObject":
		return visitor.VisitSamePropertiesAsObject(s.SamePropertiesAsObject)
	case "singleProperty":
		return visitor.VisitSingleProperty(s.SingleProperty)
	case "noProperties":
		return visitor.VisitNoProperties(s.NoProperties)
	}
}

type SingleDiscriminatedUnionTypeNoProperties struct {
	DiscriminantValue *sdk.NameAndWireValue `json:"discriminantValue,omitempty" url:"discriminantValue,omitempty"`
	// Any properties included here are the base and/or extended properties from the union.
	Properties []*NamedParameter `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleDiscriminatedUnionTypeNoProperties) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleDiscriminatedUnionTypeNoProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleDiscriminatedUnionTypeNoProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleDiscriminatedUnionTypeNoProperties(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	return nil
}

func (s *SingleDiscriminatedUnionTypeNoProperties) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleDiscriminatedUnionTypeObject struct {
	TypeId            sdk.TypeId            `json:"typeId" url:"typeId"`
	DiscriminantValue *sdk.NameAndWireValue `json:"discriminantValue,omitempty" url:"discriminantValue,omitempty"`
	// Any properties included here are the base and/or extended properties from the union.
	Properties []*NamedParameter `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleDiscriminatedUnionTypeObject) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleDiscriminatedUnionTypeObject) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleDiscriminatedUnionTypeObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleDiscriminatedUnionTypeObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	return nil
}

func (s *SingleDiscriminatedUnionTypeObject) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleDiscriminatedUnionTypeSingleProperty struct {
	TypeReference     *TypeReference        `json:"typeReference,omitempty" url:"typeReference,omitempty"`
	DiscriminantValue *sdk.NameAndWireValue `json:"discriminantValue,omitempty" url:"discriminantValue,omitempty"`
	// Any properties included here are the base and/or extended properties from the union.
	Properties []*NamedParameter `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleDiscriminatedUnionTypeSingleProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleDiscriminatedUnionTypeSingleProperty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	return nil
}

func (s *SingleDiscriminatedUnionTypeSingleProperty) String() string {
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TypeReference struct {
	Type      string
	List      *TypeReference
	Literal   *LiteralType
	Map       *MapType
	Named     sdk.TypeId
	Optional  *TypeReference
	Primitive sdk.PrimitiveTypeV1
	Set       *TypeReference
	Unknown   interface{}
}

func NewTypeReferenceFromList(value *TypeReference) *TypeReference {
	return &TypeReference{Type: "list", List: value}
}

func NewTypeReferenceFromLiteral(value *LiteralType) *TypeReference {
	return &TypeReference{Type: "literal", Literal: value}
}

func NewTypeReferenceFromMap(value *MapType) *TypeReference {
	return &TypeReference{Type: "map", Map: value}
}

func NewTypeReferenceFromNamed(value sdk.TypeId) *TypeReference {
	return &TypeReference{Type: "named", Named: value}
}

func NewTypeReferenceFromOptional(value *TypeReference) *TypeReference {
	return &TypeReference{Type: "optional", Optional: value}
}

func NewTypeReferenceFromPrimitive(value sdk.PrimitiveTypeV1) *TypeReference {
	return &TypeReference{Type: "primitive", Primitive: value}
}

func NewTypeReferenceFromSet(value *TypeReference) *TypeReference {
	return &TypeReference{Type: "set", Set: value}
}

func NewTypeReferenceFromUnknown(value interface{}) *TypeReference {
	return &TypeReference{Type: "unknown", Unknown: value}
}

func (t *TypeReference) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant _type", t)
	}
	switch unmarshaler.Type {
	case "list":
		var valueUnmarshaler struct {
			List *TypeReference `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.List = valueUnmarshaler.List
	case "literal":
		var valueUnmarshaler struct {
			Literal *LiteralType `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Literal = valueUnmarshaler.Literal
	case "map":
		value := new(MapType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Map = value
	case "named":
		var valueUnmarshaler struct {
			Named sdk.TypeId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Named = valueUnmarshaler.Named
	case "optional":
		var valueUnmarshaler struct {
			Optional *TypeReference `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Optional = valueUnmarshaler.Optional
	case "primitive":
		var valueUnmarshaler struct {
			Primitive sdk.PrimitiveTypeV1 `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Primitive = valueUnmarshaler.Primitive
	case "set":
		var valueUnmarshaler struct {
			Set *TypeReference `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.Set = valueUnmarshaler.Set
	case "unknown":
		value := make(map[string]interface{})
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Unknown = value
	}
	return nil
}

func (t TypeReference) MarshalJSON() ([]byte, error) {
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "list":
		var marshaler = struct {
			Type string         `json:"_type"`
			List *TypeReference `json:"value,omitempty"`
		}{
			Type: "list",
			List: t.List,
		}
		return json.Marshal(marshaler)
	case "literal":
		var marshaler = struct {
			Type    string       `json:"_type"`
			Literal *LiteralType `json:"value,omitempty"`
		}{
			Type:    "literal",
			Literal: t.Literal,
		}
		return json.Marshal(marshaler)
	case "map":
		return core.MarshalJSONWithExtraProperty(t.Map, "_type", "map")
	case "named":
		var marshaler = struct {
			Type  string     `json:"_type"`
			Named sdk.TypeId `json:"value"`
		}{
			Type:  "named",
			Named: t.Named,
		}
		return json.Marshal(marshaler)
	case "optional":
		var marshaler = struct {
			Type     string         `json:"_type"`
			Optional *TypeReference `json:"value,omitempty"`
		}{
			Type:     "optional",
			Optional: t.Optional,
		}
		return json.Marshal(marshaler)
	case "primitive":
		var marshaler = struct {
			Type      string              `json:"_type"`
			Primitive sdk.PrimitiveTypeV1 `json:"value"`
		}{
			Type:      "primitive",
			Primitive: t.Primitive,
		}
		return json.Marshal(marshaler)
	case "set":
		var marshaler = struct {
			Type string         `json:"_type"`
			Set  *TypeReference `json:"value,omitempty"`
		}{
			Type: "set",
			Set:  t.Set,
		}
		return json.Marshal(marshaler)
	case "unknown":
		var marshaler = struct {
			Type    string      `json:"_type"`
			Unknown interface{} `json:"unknown,omitempty"`
		}{
			Type:    "unknown",
			Unknown: t.Unknown,
		}
		return json.Marshal(marshaler)
	}
}

type TypeReferenceVisitor interface {
	VisitList(*TypeReference) error
	VisitLiteral(*LiteralType) error
	VisitMap(*MapType) error
	VisitNamed(sdk.TypeId) error
	VisitOptional(*TypeReference) error
	VisitPrimitive(sdk.PrimitiveTypeV1) error
	VisitSet(*TypeReference) error
	VisitUnknown(interface{}) error
}

func (t *TypeReference) Accept(visitor TypeReferenceVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "list":
		return visitor.VisitList(t.List)
	case "literal":
		return visitor.VisitLiteral(t.Literal)
	case "map":
		return visitor.VisitMap(t.Map)
	case "named":
		return visitor.VisitNamed(t.Named)
	case "optional":
		return visitor.VisitOptional(t.Optional)
	case "primitive":
		return visitor.VisitPrimitive(t.Primitive)
	case "set":
		return visitor.VisitSet(t.Set)
	case "unknown":
		return visitor.VisitUnknown(t.Unknown)
	}
}

type UndiscriminatedUnionType struct {
	Declaration *Declaration `json:"declaration,omitempty" url:"declaration,omitempty"`
	// The dynamic type will be rendered with the first type that matches.
	Types []*TypeReference `json:"types,omitempty" url:"types,omitempty"`

	extraProperties map[string]interface{}
}

func (u *UndiscriminatedUnionType) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UndiscriminatedUnionType) UnmarshalJSON(data []byte) error {
	type unmarshaler UndiscriminatedUnionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UndiscriminatedUnionType(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	return nil
}

func (u *UndiscriminatedUnionType) String() string {
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
