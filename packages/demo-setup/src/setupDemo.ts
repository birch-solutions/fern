/* eslint-disable no-console */
import { getUserToken } from "@fern-api/auth";
import { FernPostman, FernPostmanClient } from "@fern-fern/postman-sdk";
import { FernVenusApiClient } from "@fern-fern/venus-api-sdk";
import sodium from "libsodium-wrappers";
import { Octokit } from "octokit";

export interface SetupDemoArgs {
    postmanApiKey: string;
    githubAccessToken: string;
    npmToken: string;
    orgId: string;
    orgDisplayName: string;
    fernToken: string;
    githubOrgId: string;
}

const FERN_API_GITHUB_ORG = "fern-api";
const TEMPLATE_API_GITHUB_REPO = "template-api";
const TEMPLATE_NODE_GITHUB_REPO = "template-node";
const TEMPLATE_POSTMAN_GITHUB_REPO = "template-openapi";
const TEMPLATE_OPENAPI_GITHUB_REPO = "template-postman";

export async function setupDemo(args: SetupDemoArgs): Promise<void> {
    // Step 1: Read Fern user token
    const fernUserToken = await getUserToken();
    if (fernUserToken == null) {
        throw new Error("Run fern login before running this CLI.");
    }

    // Step 2: Create Fern org
    const venus = new FernVenusApiClient({
        environment: "https://venus.buildwithfern.com",
        token: fernUserToken.value,
    });
    await createFernOrg(args, venus);

    // Step 3: Create Fern access token for Org
    const fernAccessToken = await getFernAccessToken(venus, args);

    // Step 4: Create Postman Workspace
    const postmanWorkspaceId = await createPostmanWorkspace(args);

    // Step 5: Create API Repo
    const octokit = new Octokit({ auth: args.githubAccessToken });
    await createApiRepo(octokit, {
        args,
        fernAccessToken,
        postmanWorkspaceId,
    });

    // Step 6: Create NodeJS Repo
    await createFromTemplateRepo(octokit, {
        description: `Official Node.JS SDK for the ${args.orgDisplayName} API`,
        templateRepo: TEMPLATE_API_GITHUB_REPO,
        repo: `${args.orgId}-node`,
        owner: args.githubOrgId,
    });

    // Step 7: Create Postman Repo
    await createFromTemplateRepo(octokit, {
        description: `A Postman Collection for the ${args.orgDisplayName} API`,
        templateRepo: TEMPLATE_API_GITHUB_REPO,
        repo: `${args.orgId}-postman`,
        owner: args.githubOrgId,
    });

    // Step 8: Create OpenAPI Repo
    await createFromTemplateRepo(octokit, {
        description: `An OpenAPI spec for the ${args.orgDisplayName} API`,
        templateRepo: TEMPLATE_API_GITHUB_REPO,
        repo: `${args.orgId}-openapi`,
        owner: args.githubOrgId,
    });
}

async function createPostmanWorkspace(args: SetupDemoArgs): Promise<string> {
    const postman = new FernPostmanClient({
        apiKey: args.postmanApiKey,
    });
    const createWorkspaceResponse = await postman.workspace.create({
        name: `fern-${args.orgId}`,
        description: `${args.orgDisplayName}'s API, generated by Fern`,
        type: FernPostman.WorkspaceType.Public,
    });
    return createWorkspaceResponse.workspace.id;
}

async function createFernOrg(args: SetupDemoArgs, venus: FernVenusApiClient): Promise<void> {
    console.log("Creating organization in fern...");
    const createOrgResponse = await venus.organization.create({
        organizationId: args.orgId,
    });
    if (!createOrgResponse.ok) {
        throw new Error(`Failed to create org ${args.orgId}, ${JSON.stringify(createOrgResponse.error)}`);
    }
    console.log(`Successfully created organization ${args.orgId} in fern...`);
}

async function getFernAccessToken(venus: FernVenusApiClient, args: SetupDemoArgs): Promise<string> {
    console.log(`Creating access token in fern for ${args.orgId}...`);
    const generateRegistryTokensResponse = await venus.registry.generateRegistryTokens({
        organizationId: args.orgId,
    });
    console.log("Successfully created access token...");
    if (generateRegistryTokensResponse.ok) {
        return generateRegistryTokensResponse.body.npm.token;
    } else {
        throw new Error(`Failed to create access token for org ${args.orgId}`);
    }
}

const FERN_NPM_TOKEN_SECRET_NAME = "FERN_NPM_TOKEN";
const FERN_POSTMAN_API_KEY_SECRET_NAME = "FERN_POSTMAN_API_KEY";
const FERN_POSTMAN_WORKSPACE_ID_SECRET_NAME = "FERN_POSTMAN_WORKSPACE_ID";
const FERN_TOKEN_SECRET_NAME = "FERN_TOKEN";

interface CreateApiRepoArgs {
    args: SetupDemoArgs;
    postmanWorkspaceId: string;
    fernAccessToken: string;
}

async function createApiRepo(octokit: Octokit, createApiRepoArgs: CreateApiRepoArgs): Promise<void> {
    const apiRepoName = `${createApiRepoArgs.args.orgId}-api`;
    await createFromTemplateRepo(octokit, {
        description: `${createApiRepoArgs.args.orgDisplayName}â€™s Fern API which is used to generate SDKs.`,
        templateRepo: TEMPLATE_API_GITHUB_REPO,
        repo: apiRepoName,
        owner: createApiRepoArgs.args.githubOrgId,
    });

    await createOrUpdateSecret(octokit, {
        repo: apiRepoName,
        owner: createApiRepoArgs.args.githubOrgId,
        secretName: FERN_NPM_TOKEN_SECRET_NAME,
        secretValue: createApiRepoArgs.args.npmToken,
    });
    await createOrUpdateSecret(octokit, {
        repo: apiRepoName,
        owner: createApiRepoArgs.args.githubOrgId,
        secretName: FERN_POSTMAN_API_KEY_SECRET_NAME,
        secretValue: createApiRepoArgs.args.postmanApiKey,
    });
    await createOrUpdateSecret(octokit, {
        repo: apiRepoName,
        owner: createApiRepoArgs.args.githubOrgId,
        secretName: FERN_POSTMAN_WORKSPACE_ID_SECRET_NAME,
        secretValue: createApiRepoArgs.postmanWorkspaceId,
    });
    await createOrUpdateSecret(octokit, {
        repo: apiRepoName,
        owner: createApiRepoArgs.args.githubOrgId,
        secretName: FERN_TOKEN_SECRET_NAME,
        secretValue: createApiRepoArgs.fernAccessToken,
    });
}

interface CreateFromTemplateRepoArgs {
    description: string;
    templateRepo: string;
    repo: string;
    owner: string;
}

async function createFromTemplateRepo(octokit: Octokit, args: CreateFromTemplateRepoArgs): Promise<number> {
    const createRepoResponse = await octokit.rest.repos.createUsingTemplate({
        template_owner: FERN_API_GITHUB_ORG,
        template_repo: args.templateRepo,
        owner: args.owner,
        name: args.repo,
        description: args.description,
    });
    return createRepoResponse.data.id;
}

interface CreateSecretRequest {
    owner: string;
    repo: string;
    secretName: string;
    secretValue: string;
}

async function createOrUpdateSecret(octokit: Octokit, createSecretRequest: CreateSecretRequest) {
    console.log(
        `Creating secret ${createSecretRequest.secretName} in ${createSecretRequest.owner}/${createSecretRequest.repo}`
    );
    const encryptedSecret = await encryptSecret({
        octokit,
        value: createSecretRequest.secretValue,
        owner: createSecretRequest.owner,
        repo: createSecretRequest.repo,
    });
    const createSecretResponse = await octokit.request("PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}", {
        owner: createSecretRequest.owner,
        repo: createSecretRequest.repo,
        secret_name: createSecretRequest.secretName,
        encrypted_value: encryptedSecret.encrypted_value,
        key_id: encryptedSecret.key_id,
    });
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (createSecretResponse.status < 400) {
        console.log(
            `Successfully created secret ${createSecretRequest.secretName} in ${createSecretRequest.owner}/${createSecretRequest.repo}`
        );
    } else {
        throw new Error(
            `Failed to create secret ${createSecretRequest.secretName} in ${createSecretRequest.owner}/${createSecretRequest.repo}`
        );
    }
}

interface EncryptedSecret {
    key_id: string;
    encrypted_value: string;
}

async function encryptSecret({
    octokit,
    value,
    owner,
    repo,
}: {
    octokit: Octokit;
    value: string;
    owner: string;
    repo: string;
}): Promise<EncryptedSecret> {
    const { data } = await octokit.request("GET /repos/{owner}/{repo}/actions/secrets/public-key", {
        owner,
        repo,
    });

    await sodium.ready;

    // Convert Secret & Base64 key to Uint8Array.
    const binkey = sodium.from_base64(data.key, sodium.base64_variants.ORIGINAL);
    const binsec = sodium.from_string(value);

    // Encrypt the secret using LibSodium
    const encryptedBytes = sodium.crypto_box_seal(binsec, binkey);

    return {
        key_id: data.key_id,
        // Base64 the encrypted secret
        encrypted_value: sodium.to_base64(encryptedBytes, sodium.base64_variants.ORIGINAL),
    };
}
