// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`fern generate 1`] = `
[
  {
    "contents": [
      {
        "contents": [
          {
            "contents": [
              {
                "contents": "name: api
error-discrimination:
  strategy: status-code
",
                "name": "api.yml",
                "type": "file",
              },
              {
                "contents": "# yaml-language-server: $schema=https://raw.githubusercontent.com/fern-api/fern/main/fern.schema.json

service:
  auth: false
  base-path: /movies
  endpoints:
    createMovie:
      docs: Add a movie to the database
      method: POST
      path: /create-movie
      request: CreateMovieRequest
      response: MovieId

    getMovie:
      docs: Retrieve a movie from the database based on the ID
      method: GET
      path: /{id}
      path-parameters:
        id: MovieId
      response: Movie
      errors:
        - MovieDoesNotExistError
      examples:
        # Success response
        - path-parameters:
            id: tt0111161
          response:
            body:
              id: tt0111161
              title: The Shawshank Redemption
              rating: 9.3
        # Error response
        - path-parameters:
            id: tt1234
          response:
            error: MovieDoesNotExistError
            body: tt1234

types:
  MovieId:
    type: string
    docs: The unique identifier for a Movie in the database

  Movie:
    properties:
      id: MovieId
      title: string
      rating:
        type: double
        docs: The rating scale out of ten stars

  CreateMovieRequest:
    properties:
      title: string
      rating: double

errors:
  MovieDoesNotExistError:
    status-code: 404
    type: MovieId
",
                "name": "imdb.yml",
                "type": "file",
              },
            ],
            "name": "definition",
            "type": "directory",
          },
          {
            "contents": "default-group: local
groups:
  local:
    generators:
      - name: fernapi/fern-typescript-sdk
        version: 0.2.2
        output:
          location: local-file-system
          path: ../../generated/typescript
      - name: fernapi/fern-openapi
        version: 0.0.22
        output:
          location: local-file-system
          path: ../../generated/openapi
",
            "name": "generators.yml",
            "type": "file",
          },
        ],
        "name": "api",
        "type": "directory",
      },
      {
        "contents": "{
    "organization": "fern",
    "version": "0.0.0"
}",
        "name": "fern.config.json",
        "type": "file",
      },
    ],
    "name": "fern",
    "type": "directory",
  },
  {
    "contents": [
      {
        "contents": [
          {
            "contents": "openapi: 3.0.1
info:
  title: api
  version: ''
paths:
  /movies/create-movie:
    post:
      description: Add a movie to the database
      operationId: imdb_createMovie
      tags:
        - Imdb
      parameters: []
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MovieId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateMovieRequest'
  /movies/{id}:
    get:
      description: Retrieve a movie from the database based on the ID
      operationId: imdb_getMovie
      tags:
        - Imdb
      parameters:
        - name: id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/MovieId'
          examples:
            Example1:
              value: tt0111161
            Example2:
              value: tt1234
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Movie'
              examples:
                Example1:
                  value:
                    id: tt0111161
                    title: The Shawshank Redemption
                    rating: 9.3
        '404':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MovieId'
              examples:
                Example1:
                  value: tt1234
components:
  schemas:
    MovieId:
      type: string
      description: The unique identifier for a Movie in the database
    Movie:
      type: object
      properties:
        id:
          $ref: '#/components/schemas/MovieId'
        title:
          type: string
          example: The Shawshank Redemption
        rating:
          type: number
          format: double
          description: The rating scale out of ten stars
          example: 9.3
      required:
        - id
        - title
        - rating
    CreateMovieRequest:
      type: object
      properties:
        title:
          type: string
        rating:
          type: number
          format: double
      required:
        - title
        - rating
  securitySchemes: {}
",
            "name": "openapi.yml",
            "type": "file",
          },
        ],
        "name": "openapi",
        "type": "directory",
      },
      {
        "contents": [
          {
            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import { Client as ImdbClient } from "./api/resources/imdb/client/Client";
export declare namespace FernApiClient {
    interface Options {
        environment: string;
    }
}
export declare class FernApiClient {
    #private;
    private readonly options;
    constructor(options: FernApiClient.Options);
    get imdb(): ImdbClient;
}
",
            "name": "Client.d.ts",
            "type": "file",
          },
          {
            "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FernApiClient = void 0;
const Client_1 = require("./api/resources/imdb/client/Client");
class FernApiClient {
    options;
    constructor(options) {
        this.options = options;
    }
    #imdb;
    get imdb() {
        return (this.#imdb ??= new Client_1.Client(this.options));
    }
}
exports.FernApiClient = FernApiClient;
",
            "name": "Client.js",
            "type": "file",
          },
          {
            "contents": [
              {
                "contents": "export * from "./resources";
",
                "name": "index.d.ts",
                "type": "file",
              },
              {
                "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./resources"), exports);
",
                "name": "index.js",
                "type": "file",
              },
              {
                "contents": [
                  {
                    "contents": [
                      {
                        "contents": [
                          {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import { FernApi } from "../../../..";
export declare namespace Client {
    interface Options {
        environment: string;
    }
}
export declare class Client {
    private readonly options;
    constructor(options: Client.Options);
    /**
     * Add a movie to the database
     */
    createMovie(request: FernApi.CreateMovieRequest): Promise<FernApi.MovieId>;
    /**
     * Retrieve a movie from the database based on the ID
     * @throws {FernApi.MovieDoesNotExistError}
     */
    getMovie(id: FernApi.MovieId): Promise<FernApi.Movie>;
}
",
                            "name": "Client.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const __1 = require("../../../..");
const url_join_1 = __importDefault(require("url-join"));
const serializers = __importStar(require("../../../../serialization"));
const core = __importStar(require("../../../../core"));
const errors = __importStar(require("../../../../errors"));
class Client {
    options;
    constructor(options) {
        this.options = options;
    }
    /**
     * Add a movie to the database
     */
    async createMovie(request) {
        const _response = await core.fetcher({
            url: (0, url_join_1.default)(this.options.environment, "/movies/create-movie"),
            method: "POST",
            body: await serializers.CreateMovieRequest.jsonOrThrow(request),
        });
        if (_response.ok) {
            return await serializers.MovieId.parseOrThrow(_response.body, {
                allowUnknownKeys: true,
            });
        }
        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }
        switch (_response.error.reason) {
            case "non-json":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.FernApiTimeoutError();
            case "unknown":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
    /**
     * Retrieve a movie from the database based on the ID
     * @throws {FernApi.MovieDoesNotExistError}
     */
    async getMovie(id) {
        const _response = await core.fetcher({
            url: (0, url_join_1.default)(this.options.environment, \`/movies/\${await serializers.MovieId.jsonOrThrow(id)}\`),
            method: "GET",
        });
        if (_response.ok) {
            return await serializers.Movie.parseOrThrow(_response.body, {
                allowUnknownKeys: true,
            });
        }
        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new __1.FernApi.MovieDoesNotExistError(await serializers.MovieId.parseOrThrow(_response.error.body, {
                        allowUnknownKeys: true,
                    }));
                default:
                    throw new errors.FernApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }
        switch (_response.error.reason) {
            case "non-json":
                throw new errors.FernApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.FernApiTimeoutError();
            case "unknown":
                throw new errors.FernApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
exports.Client = Client;
",
                            "name": "Client.js",
                            "type": "file",
                          },
                          {
                            "contents": "export {};
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
",
                            "name": "index.js",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as errors from "../../../../errors";
import { FernApi } from "../../../..";
export declare class MovieDoesNotExistError extends errors.FernApiError {
    constructor(body: FernApi.MovieId);
}
",
                            "name": "MovieDoesNotExistError.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MovieDoesNotExistError = void 0;
const errors = __importStar(require("../../../../errors"));
class MovieDoesNotExistError extends errors.FernApiError {
    constructor(body) {
        super({
            message: "MovieDoesNotExistError",
            statusCode: 404,
            body: body,
        });
        Object.setPrototypeOf(this, MovieDoesNotExistError.prototype);
    }
}
exports.MovieDoesNotExistError = MovieDoesNotExistError;
",
                            "name": "MovieDoesNotExistError.js",
                            "type": "file",
                          },
                          {
                            "contents": "export * from "./MovieDoesNotExistError";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./MovieDoesNotExistError"), exports);
",
                            "name": "index.js",
                            "type": "file",
                          },
                        ],
                        "name": "errors",
                        "type": "directory",
                      },
                      {
                        "contents": "export * from "./types";
export * from "./errors";
export * from "./client";
",
                        "name": "index.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./types"), exports);
__exportStar(require("./errors"), exports);
__exportStar(require("./client"), exports);
",
                        "name": "index.js",
                        "type": "file",
                      },
                      {
                        "contents": [
                          {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
export interface CreateMovieRequest {
    title: string;
    rating: number;
}
",
                            "name": "CreateMovieRequest.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, "__esModule", { value: true });
",
                            "name": "CreateMovieRequest.js",
                            "type": "file",
                          },
                          {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import { FernApi } from "../../../..";
export interface Movie {
    id: FernApi.MovieId;
    title: string;
    /** The rating scale out of ten stars */
    rating: number;
}
",
                            "name": "Movie.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, "__esModule", { value: true });
",
                            "name": "Movie.js",
                            "type": "file",
                          },
                          {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
/**
 * The unique identifier for a Movie in the database
 */
export declare type MovieId = string;
",
                            "name": "MovieId.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, "__esModule", { value: true });
",
                            "name": "MovieId.js",
                            "type": "file",
                          },
                          {
                            "contents": "export * from "./MovieId";
export * from "./Movie";
export * from "./CreateMovieRequest";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./MovieId"), exports);
__exportStar(require("./Movie"), exports);
__exportStar(require("./CreateMovieRequest"), exports);
",
                            "name": "index.js",
                            "type": "file",
                          },
                        ],
                        "name": "types",
                        "type": "directory",
                      },
                    ],
                    "name": "imdb",
                    "type": "directory",
                  },
                  {
                    "contents": "export * as imdb from "./imdb";
export * from "./imdb/types";
export * from "./imdb/errors";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  {
                    "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.imdb = void 0;
exports.imdb = __importStar(require("./imdb"));
__exportStar(require("./imdb/types"), exports);
__exportStar(require("./imdb/errors"), exports);
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "resources",
                "type": "directory",
              },
            ],
            "name": "api",
            "type": "directory",
          },
          {
            "contents": [
              {
                "contents": [
                  {
                    "contents": "export declare type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;
export interface SuccessfulResponse<T> {
    ok: true;
    body: T;
}
export interface FailedResponse<T> {
    ok: false;
    error: T;
}
",
                    "name": "APIResponse.d.ts",
                    "type": "file",
                  },
                  {
                    "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
",
                    "name": "APIResponse.js",
                    "type": "file",
                  },
                  {
                    "contents": "import { APIResponse } from "./APIResponse";
export interface Fetcher {
    fetch: FetchFunction;
}
export declare type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;
export declare namespace Fetcher {
    interface Args {
        url: string;
        method: string;
        headers?: Record<string, string | undefined>;
        queryParameters?: URLSearchParams;
        body?: unknown;
        timeoutMs?: number;
        withCredentials?: boolean;
    }
    type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;
    interface FailedStatusCodeError {
        reason: "status-code";
        statusCode: number;
        body: unknown;
    }
    interface NonJsonError {
        reason: "non-json";
        statusCode: number;
        rawBody: string;
    }
    interface TimeoutError {
        reason: "timeout";
    }
    interface UnknownError {
        reason: "unknown";
        errorMessage: string;
    }
}
export declare const fetcher: FetchFunction;
",
                    "name": "Fetcher.d.ts",
                    "type": "file",
                  },
                  {
                    "contents": ""use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetcher = void 0;
const axios_1 = __importDefault(require("axios"));
const fetcher = async (args) => {
    const headers = {
        "Content-Type": "application/json",
    };
    if (args.headers != null) {
        for (const [key, value] of Object.entries(args.headers)) {
            if (value != null) {
                headers[key] = value;
            }
        }
    }
    try {
        const response = await (0, axios_1.default)({
            url: args.url,
            params: args.queryParameters,
            method: args.method,
            headers,
            data: args.body,
            validateStatus: () => true,
            transformResponse: (response) => response,
            timeout: args.timeoutMs ?? 60_000,
            transitional: {
                clarifyTimeoutError: true,
            },
            withCredentials: args.withCredentials,
        });
        let body;
        if (response.data != null && response.data.length > 0) {
            try {
                body = JSON.parse(response.data) ?? undefined;
            }
            catch {
                return {
                    ok: false,
                    error: {
                        reason: "non-json",
                        statusCode: response.status,
                        rawBody: response.data,
                    },
                };
            }
        }
        if (response.status >= 200 && response.status < 300) {
            return {
                ok: true,
                body,
            };
        }
        else {
            return {
                ok: false,
                error: {
                    reason: "status-code",
                    statusCode: response.status,
                    body,
                },
            };
        }
    }
    catch (error) {
        if (error.code === "ETIMEDOUT") {
            return {
                ok: false,
                error: {
                    reason: "timeout",
                },
            };
        }
        return {
            ok: false,
            error: {
                reason: "unknown",
                errorMessage: error.message,
            },
        };
    }
};
exports.fetcher = fetcher;
",
                    "name": "Fetcher.js",
                    "type": "file",
                  },
                  {
                    "contents": "export declare type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);
export declare const Supplier: {
    get: <T>(supplier: Supplier<T>) => Promise<T>;
};
",
                    "name": "Supplier.d.ts",
                    "type": "file",
                  },
                  {
                    "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Supplier = void 0;
exports.Supplier = {
    get: async (supplier) => {
        if (typeof supplier === "function") {
            return supplier();
        }
        else {
            return supplier;
        }
    },
};
",
                    "name": "Supplier.js",
                    "type": "file",
                  },
                  {
                    "contents": "export { type APIResponse } from "./APIResponse";
export { fetcher, type Fetcher, type FetchFunction } from "./Fetcher";
export { Supplier } from "./Supplier";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  {
                    "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Supplier = exports.fetcher = void 0;
var Fetcher_1 = require("./Fetcher");
Object.defineProperty(exports, "fetcher", { enumerable: true, get: function () { return Fetcher_1.fetcher; } });
var Supplier_1 = require("./Supplier");
Object.defineProperty(exports, "Supplier", { enumerable: true, get: function () { return Supplier_1.Supplier; } });
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "fetcher",
                "type": "directory",
              },
              {
                "contents": "export * as serialization from "./schemas";
export * from "./fetcher";
",
                "name": "index.d.ts",
                "type": "file",
              },
              {
                "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serialization = void 0;
exports.serialization = __importStar(require("./schemas"));
__exportStar(require("./fetcher"), exports);
",
                "name": "index.js",
                "type": "file",
              },
              {
                "contents": [
                  {
                    "contents": "import { SchemaUtils } from "./builders";
import { MaybePromise } from "./utils/MaybePromise";
export declare type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;
export declare type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export declare type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;
export interface BaseSchema<Raw, Parsed> {
    parse: (raw: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Parsed>>;
    json: (parsed: unknown, opts?: SchemaOptions) => MaybePromise<MaybeValid<Raw>>;
    getType: () => SchemaType | Promise<SchemaType>;
}
export declare const SchemaType: {
    readonly DATE: "date";
    readonly ENUM: "enum";
    readonly LIST: "list";
    readonly STRING_LITERAL: "stringLiteral";
    readonly OBJECT: "object";
    readonly ANY: "any";
    readonly BOOLEAN: "boolean";
    readonly NUMBER: "number";
    readonly STRING: "string";
    readonly UNKNOWN: "unknown";
    readonly RECORD: "record";
    readonly SET: "set";
    readonly UNION: "union";
    readonly OPTIONAL: "optional";
};
export declare type SchemaType = typeof SchemaType[keyof typeof SchemaType];
export declare type MaybeValid<T> = Valid<T> | Invalid;
export interface Valid<T> {
    ok: true;
    value: T;
}
export interface Invalid {
    ok: false;
    errors: ValidationError[];
}
export interface ValidationError {
    path: string[];
    message: string;
}
export interface SchemaOptions {
    /**
     * @default false
     */
    allowUnknownKeys?: boolean;
}
",
                    "name": "Schema.d.ts",
                    "type": "file",
                  },
                  {
                    "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaType = void 0;
exports.SchemaType = {
    DATE: "date",
    ENUM: "enum",
    LIST: "list",
    STRING_LITERAL: "stringLiteral",
    OBJECT: "object",
    ANY: "any",
    BOOLEAN: "boolean",
    NUMBER: "number",
    STRING: "string",
    UNKNOWN: "unknown",
    RECORD: "record",
    SET: "set",
    UNION: "union",
    OPTIONAL: "optional",
};
",
                    "name": "Schema.js",
                    "type": "file",
                  },
                  {
                    "contents": [
                      {
                        "contents": [
                          {
                            "contents": "import { Schema } from "../../Schema";
export declare function date(): Schema<string, Date>;
",
                            "name": "date.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.date = void 0;
const Schema_1 = require("../../Schema");
const schema_utils_1 = require("../schema-utils");
// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
const ISO_8601_REGEX = /^([+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([.,]\\d+(?!:))?)?(\\17[0-5]\\d([.,]\\d+)?)?([zZ]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;
function date() {
    const baseSchema = {
        parse: (raw) => {
            if (typeof raw === "string" && ISO_8601_REGEX.test(raw)) {
                return {
                    ok: true,
                    value: new Date(raw),
                };
            }
            else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: "Not an ISO 8601 date string",
                        },
                    ],
                };
            }
        },
        json: (date) => {
            if (date instanceof Date) {
                return {
                    ok: true,
                    value: date.toISOString(),
                };
            }
            else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: "Not a Date object",
                        },
                    ],
                };
            }
        },
        getType: () => Schema_1.SchemaType.DATE,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
    };
}
exports.date = date;
",
                            "name": "date.js",
                            "type": "file",
                          },
                          {
                            "contents": "export { date } from "./date";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.date = void 0;
var date_1 = require("./date");
Object.defineProperty(exports, "date", { enumerable: true, get: function () { return date_1.date; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                        ],
                        "name": "date",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "import { Schema } from "../../Schema";
export declare function enum_<U extends string, E extends U[]>(values: E): Schema<E[number], E[number]>;
",
                            "name": "enum.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enum_ = void 0;
const Schema_1 = require("../../Schema");
const createIdentitySchemaCreator_1 = require("../../utils/createIdentitySchemaCreator");
function enum_(values) {
    const validValues = new Set(values);
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ENUM, (value, { allowUnknownKeys = false } = {}) => {
        if (typeof value === "string" && (validValues.has(value) || allowUnknownKeys)) {
            return {
                ok: true,
                value: value,
            };
        }
        else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: "Not one of the allowed values",
                    },
                ],
            };
        }
    });
    return schemaCreator();
}
exports.enum_ = enum_;
",
                            "name": "enum.js",
                            "type": "file",
                          },
                          {
                            "contents": "export { enum_ } from "./enum";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enum_ = void 0;
var enum_1 = require("./enum");
Object.defineProperty(exports, "enum_", { enumerable: true, get: function () { return enum_1.enum_; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                        ],
                        "name": "enum",
                        "type": "directory",
                      },
                      {
                        "contents": "export * from "./date";
export * from "./enum";
export * from "./lazy";
export * from "./list";
export * from "./literals";
export * from "./object";
export * from "./object-like";
export * from "./primitives";
export * from "./record";
export * from "./schema-utils";
export * from "./set";
export * from "./union";
",
                        "name": "index.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./date"), exports);
__exportStar(require("./enum"), exports);
__exportStar(require("./lazy"), exports);
__exportStar(require("./list"), exports);
__exportStar(require("./literals"), exports);
__exportStar(require("./object"), exports);
__exportStar(require("./object-like"), exports);
__exportStar(require("./primitives"), exports);
__exportStar(require("./record"), exports);
__exportStar(require("./schema-utils"), exports);
__exportStar(require("./set"), exports);
__exportStar(require("./union"), exports);
",
                        "name": "index.js",
                        "type": "file",
                      },
                      {
                        "contents": [
                          {
                            "contents": "export { lazy, type SchemaGetter } from "./lazy";
export { lazyObject } from "./lazyObject";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lazyObject = exports.lazy = void 0;
var lazy_1 = require("./lazy");
Object.defineProperty(exports, "lazy", { enumerable: true, get: function () { return lazy_1.lazy; } });
var lazyObject_1 = require("./lazyObject");
Object.defineProperty(exports, "lazyObject", { enumerable: true, get: function () { return lazyObject_1.lazyObject; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { BaseSchema, Schema } from "../../Schema";
export declare type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;
export declare function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed>;
export declare function constructLazyBaseSchema<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): BaseSchema<Raw, Parsed>;
export declare function getMemoizedSchema<SchemaType extends Schema<any, any>>(getter: SchemaGetter<SchemaType>): Promise<SchemaType>;
",
                            "name": "lazy.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMemoizedSchema = exports.constructLazyBaseSchema = exports.lazy = void 0;
const schema_utils_1 = require("../schema-utils");
function lazy(getter) {
    const baseSchema = constructLazyBaseSchema(getter);
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
    };
}
exports.lazy = lazy;
function constructLazyBaseSchema(getter) {
    return {
        parse: async (raw, opts) => (await getMemoizedSchema(getter)).parse(raw, opts),
        json: async (parsed, opts) => (await getMemoizedSchema(getter)).json(parsed, opts),
        getType: async () => (await getMemoizedSchema(getter)).getType(),
    };
}
exports.constructLazyBaseSchema = constructLazyBaseSchema;
async function getMemoizedSchema(getter) {
    const castedGetter = getter;
    if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = await getter();
    }
    return castedGetter.__zurg_memoized;
}
exports.getMemoizedSchema = getMemoizedSchema;
",
                            "name": "lazy.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { ObjectSchema } from "../object/types";
import { SchemaGetter } from "./lazy";
export declare function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed>;
",
                            "name": "lazyObject.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lazyObject = void 0;
const object_1 = require("../object");
const object_like_1 = require("../object-like");
const schema_utils_1 = require("../schema-utils");
const lazy_1 = require("./lazy");
function lazyObject(getter) {
    const baseSchema = {
        ...(0, lazy_1.constructLazyBaseSchema)(getter),
        _getRawProperties: async () => (await (0, lazy_1.getMemoizedSchema)(getter))._getRawProperties(),
        _getParsedProperties: async () => (await (0, lazy_1.getMemoizedSchema)(getter))._getParsedProperties(),
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
        ...(0, object_like_1.getObjectLikeUtils)(baseSchema),
        ...(0, object_1.getObjectUtils)(baseSchema),
    };
}
exports.lazyObject = lazyObject;
",
                            "name": "lazyObject.js",
                            "type": "file",
                          },
                        ],
                        "name": "lazy",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "export { list } from "./list";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.list = void 0;
var list_1 = require("./list");
Object.defineProperty(exports, "list", { enumerable: true, get: function () { return list_1.list; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { Schema } from "../../Schema";
export declare function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]>;
",
                            "name": "list.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.list = void 0;
const Schema_1 = require("../../Schema");
const schema_utils_1 = require("../schema-utils");
function list(schema) {
    const baseSchema = {
        parse: async (raw, opts) => validateAndTransformArray(raw, (item) => schema.parse(item, opts)),
        json: (parsed, opts) => validateAndTransformArray(parsed, (item) => schema.json(item, opts)),
        getType: () => Schema_1.SchemaType.LIST,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
    };
}
exports.list = list;
async function validateAndTransformArray(value, transformItem) {
    if (!Array.isArray(value)) {
        return {
            ok: false,
            errors: [
                {
                    message: "Not a list",
                    path: [],
                },
            ],
        };
    }
    const maybeValidItems = await Promise.all(value.map((item) => transformItem(item)));
    return maybeValidItems.reduce((acc, item, index) => {
        if (acc.ok && item.ok) {
            return {
                ok: true,
                value: [...acc.value, item.value],
            };
        }
        const errors = [];
        if (!acc.ok) {
            errors.push(...acc.errors);
        }
        if (!item.ok) {
            errors.push(...item.errors.map((error) => ({
                path: [\`[\${index}]\`, ...error.path],
                message: error.message,
            })));
        }
        return {
            ok: false,
            errors,
        };
    }, { ok: true, value: [] });
}
",
                            "name": "list.js",
                            "type": "file",
                          },
                        ],
                        "name": "list",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "export { stringLiteral } from "./stringLiteral";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringLiteral = void 0;
var stringLiteral_1 = require("./stringLiteral");
Object.defineProperty(exports, "stringLiteral", { enumerable: true, get: function () { return stringLiteral_1.stringLiteral; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { Schema } from "../../Schema";
export declare function stringLiteral<V extends string>(literal: V): Schema<V, V>;
",
                            "name": "stringLiteral.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringLiteral = void 0;
const Schema_1 = require("../../Schema");
const createIdentitySchemaCreator_1 = require("../../utils/createIdentitySchemaCreator");
function stringLiteral(literal) {
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING_LITERAL, (value) => {
        if (value === literal) {
            return {
                ok: true,
                value: literal,
            };
        }
        else {
            return {
                ok: false,
                errors: [
                    {
                        path: [],
                        message: \`Not equal to "\${literal}"\`,
                    },
                ],
            };
        }
    });
    return schemaCreator();
}
exports.stringLiteral = stringLiteral;
",
                            "name": "stringLiteral.js",
                            "type": "file",
                          },
                        ],
                        "name": "literals",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "export { getObjectUtils, object } from "./object";
export { isProperty, property, type Property } from "./property";
export { type BaseObjectSchema, type inferObjectSchemaFromPropertySchemas, type inferParsedObject, type inferParsedObjectFromPropertySchemas, type inferParsedPropertySchema, type inferRawKey, type inferRawObject, type inferRawObjectFromPropertySchemas, type inferRawPropertySchema, type ObjectSchema, type ObjectUtils, type PropertySchemas, } from "./types";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.property = exports.isProperty = exports.object = exports.getObjectUtils = void 0;
var object_1 = require("./object");
Object.defineProperty(exports, "getObjectUtils", { enumerable: true, get: function () { return object_1.getObjectUtils; } });
Object.defineProperty(exports, "object", { enumerable: true, get: function () { return object_1.object; } });
var property_1 = require("./property");
Object.defineProperty(exports, "isProperty", { enumerable: true, get: function () { return property_1.isProperty; } });
Object.defineProperty(exports, "property", { enumerable: true, get: function () { return property_1.property; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { BaseObjectSchema, inferObjectSchemaFromPropertySchemas, ObjectUtils, PropertySchemas } from "./types";
export declare function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(schemas: T): inferObjectSchemaFromPropertySchemas<T>;
export declare function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed>;
",
                            "name": "object.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getObjectUtils = exports.object = void 0;
const Schema_1 = require("../../Schema");
const entries_1 = require("../../utils/entries");
const filterObject_1 = require("../../utils/filterObject");
const isPlainObject_1 = require("../../utils/isPlainObject");
const keys_1 = require("../../utils/keys");
const partition_1 = require("../../utils/partition");
const object_like_1 = require("../object-like");
const schema_utils_1 = require("../schema-utils");
const property_1 = require("./property");
function object(schemas) {
    const baseSchema = {
        _getRawProperties: () => Promise.resolve(Object.entries(schemas).map(([parsedKey, propertySchema]) => (0, property_1.isProperty)(propertySchema) ? propertySchema.rawKey : parsedKey)),
        _getParsedProperties: () => Promise.resolve((0, keys_1.keys)(schemas)),
        parse: async (raw, opts) => {
            const rawKeyToProperty = {};
            const requiredKeys = [];
            for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)) {
                const rawKey = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
                const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;
                const property = {
                    rawKey,
                    parsedKey: parsedKey,
                    valueSchema,
                };
                rawKeyToProperty[rawKey] = property;
                if ((await valueSchema.getType()) !== "optional") {
                    requiredKeys.push(rawKey);
                }
            }
            return validateAndTransformObject({
                value: raw,
                requiredKeys,
                getProperty: (rawKey) => {
                    const property = rawKeyToProperty[rawKey];
                    if (property == null) {
                        return undefined;
                    }
                    return {
                        transformedKey: property.parsedKey,
                        transform: (propertyValue) => property.valueSchema.parse(propertyValue, opts),
                    };
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },
        json: async (parsed, opts) => {
            const requiredKeys = [];
            for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)) {
                const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty)
                    ? schemaOrObjectProperty.valueSchema
                    : schemaOrObjectProperty;
                if ((await valueSchema.getType()) !== "optional") {
                    requiredKeys.push(parsedKey);
                }
            }
            return validateAndTransformObject({
                value: parsed,
                requiredKeys,
                getProperty: (parsedKey) => {
                    const property = schemas[parsedKey];
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (property == null) {
                        return undefined;
                    }
                    if ((0, property_1.isProperty)(property)) {
                        return {
                            transformedKey: property.rawKey,
                            transform: (propertyValue) => property.valueSchema.json(propertyValue, opts),
                        };
                    }
                    else {
                        return {
                            transformedKey: parsedKey,
                            transform: (propertyValue) => property.json(propertyValue, opts),
                        };
                    }
                },
                allowUnknownKeys: opts?.allowUnknownKeys ?? false,
            });
        },
        getType: () => Schema_1.SchemaType.OBJECT,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
        ...(0, object_like_1.getObjectLikeUtils)(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}
exports.object = object;
async function validateAndTransformObject({ value, requiredKeys, getProperty, allowUnknownKeys, }) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: isPlainObject_1.NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }
    const missingRequiredKeys = new Set(requiredKeys);
    const errors = [];
    const transformed = {};
    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
        const property = getProperty(preTransformedKey);
        if (property != null) {
            missingRequiredKeys.delete(preTransformedKey);
            const value = await property.transform(preTransformedItemValue);
            if (value.ok) {
                transformed[property.transformedKey] = value.value;
            }
            else {
                errors.push(...value.errors.map((error) => ({
                    path: [preTransformedKey, ...error.path],
                    message: error.message,
                })));
            }
        }
        else if (allowUnknownKeys) {
            transformed[preTransformedKey] = preTransformedItemValue;
        }
        else {
            errors.push({
                path: [preTransformedKey],
                message: \`Unrecognized key "\${preTransformedKey}"\`,
            });
        }
    }
    errors.push(...requiredKeys
        .filter((key) => missingRequiredKeys.has(key))
        .map((key) => ({
        path: [],
        message: \`Missing required key "\${key}"\`,
    })));
    if (errors.length === 0) {
        return {
            ok: true,
            value: transformed,
        };
    }
    else {
        return {
            ok: false,
            errors,
        };
    }
}
function getObjectUtils(schema) {
    return {
        extend: (extension) => {
            const baseSchema = {
                _getParsedProperties: async () => [
                    ...(await schema._getParsedProperties()),
                    ...(await extension._getParsedProperties()),
                ],
                _getRawProperties: async () => [
                    ...(await schema._getRawProperties()),
                    ...(await extension._getRawProperties()),
                ],
                parse: async (raw, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getRawProperties(),
                        value: raw,
                        transformBase: (rawBase) => schema.parse(rawBase, opts),
                        transformExtension: (rawExtension) => extension.parse(rawExtension, opts),
                    });
                },
                json: async (parsed, opts) => {
                    return validateAndTransformExtendedObject({
                        extensionKeys: await extension._getParsedProperties(),
                        value: parsed,
                        transformBase: (parsedBase) => schema.json(parsedBase, opts),
                        transformExtension: (parsedExtension) => extension.json(parsedExtension, opts),
                    });
                },
                getType: () => Schema_1.SchemaType.OBJECT,
            };
            return {
                ...baseSchema,
                ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
                ...(0, object_like_1.getObjectLikeUtils)(baseSchema),
                ...getObjectUtils(baseSchema),
            };
        },
    };
}
exports.getObjectUtils = getObjectUtils;
async function validateAndTransformExtendedObject({ extensionKeys, value, transformBase, transformExtension, }) {
    const extensionPropertiesSet = new Set(extensionKeys);
    const [extensionProperties, baseProperties] = (0, partition_1.partition)((0, keys_1.keys)(value), (key) => extensionPropertiesSet.has(key));
    const transformedBase = await transformBase((0, filterObject_1.filterObject)(value, baseProperties));
    const transformedExtension = await transformExtension((0, filterObject_1.filterObject)(value, extensionProperties));
    if (transformedBase.ok && transformedExtension.ok) {
        return {
            ok: true,
            value: {
                ...transformedBase.value,
                ...transformedExtension.value,
            },
        };
    }
    else {
        return {
            ok: false,
            errors: [
                ...(transformedBase.ok ? [] : transformedBase.errors),
                ...(transformedExtension.ok ? [] : transformedExtension.errors),
            ],
        };
    }
}
",
                            "name": "object.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { Schema } from "../../Schema";
export declare function property<RawKey extends string, RawValue, ParsedValue>(rawKey: RawKey, valueSchema: Schema<RawValue, ParsedValue>): Property<RawKey, RawValue, ParsedValue>;
export interface Property<RawKey extends string, RawValue, ParsedValue> {
    rawKey: RawKey;
    valueSchema: Schema<RawValue, ParsedValue>;
    isProperty: true;
}
export declare function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O;
",
                            "name": "property.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isProperty = exports.property = void 0;
function property(rawKey, valueSchema) {
    return {
        rawKey,
        valueSchema,
        isProperty: true,
    };
}
exports.property = property;
function isProperty(maybeProperty) {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return maybeProperty.isProperty;
}
exports.isProperty = isProperty;
",
                            "name": "property.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { BaseSchema, inferParsed, inferRaw, Schema } from "../../Schema";
import { addQuestionMarksToNullableProperties } from "../../utils/addQuestionMarksToNullableProperties";
import { ObjectLikeUtils } from "../object-like";
import { SchemaUtils } from "../schema-utils";
import { Property } from "./property";
export declare type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> & ObjectLikeUtils<Raw, Parsed> & ObjectUtils<Raw, Parsed> & SchemaUtils<Raw, Parsed>;
export interface BaseObjectSchema<Raw, Parsed> extends BaseSchema<Raw, Parsed> {
    _getRawProperties: () => Promise<(keyof Raw)[]>;
    _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}
export interface ObjectUtils<Raw, Parsed> {
    extend: <RawExtension, ParsedExtension>(schemas: ObjectSchema<RawExtension, ParsedExtension>) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}
export declare type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;
export declare type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed> ? Parsed : never;
export declare type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>>;
export declare type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> = addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
}>;
export declare type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> = addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
}>;
export declare type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<ParsedKeys, Property<any, any, any> | Schema<any, any>>;
export declare type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<any, infer Raw, any> ? Raw : P extends Schema<any, any> ? inferRaw<P> : never;
export declare type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<any, any, infer Parsed> ? Parsed : P extends Schema<any, any> ? inferParsed<P> : never;
export declare type inferRawKey<ParsedKey extends string | number | symbol, P extends Property<any, any, any> | Schema<any, any>> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                            "name": "types.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
",
                            "name": "types.js",
                            "type": "file",
                          },
                        ],
                        "name": "object",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "import { BaseSchema } from "../../Schema";
import { ObjectLikeSchema, ObjectLikeUtils } from "./types";
export declare function getObjectLikeUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): ObjectLikeUtils<Raw, Parsed>;
/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */
export declare function withParsedProperties<RawObjectShape, ParsedObjectShape, Properties>(objectLike: BaseSchema<RawObjectShape, ParsedObjectShape>, properties: {
    [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]);
}): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties>;
",
                            "name": "getObjectLikeUtils.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withParsedProperties = exports.getObjectLikeUtils = void 0;
const filterObject_1 = require("../../utils/filterObject");
const isPlainObject_1 = require("../../utils/isPlainObject");
const schema_utils_1 = require("../schema-utils");
function getObjectLikeUtils(schema) {
    return {
        withParsedProperties: (properties) => withParsedProperties(schema, properties),
    };
}
exports.getObjectLikeUtils = getObjectLikeUtils;
/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */
function withParsedProperties(objectLike, properties) {
    const objectSchema = {
        parse: async (raw, opts) => {
            const parsedObject = await objectLike.parse(raw, opts);
            if (!parsedObject.ok) {
                return parsedObject;
            }
            const additionalProperties = Object.entries(properties).reduce((processed, [key, value]) => {
                return {
                    ...processed,
                    [key]: typeof value === "function" ? value(parsedObject.value) : value,
                };
            }, {});
            return {
                ok: true,
                value: {
                    ...parsedObject.value,
                    ...additionalProperties,
                },
            };
        },
        json: (parsed, opts) => {
            if (!(0, isPlainObject_1.isPlainObject)(parsed)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: isPlainObject_1.NOT_AN_OBJECT_ERROR_MESSAGE,
                        },
                    ],
                };
            }
            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = (0, filterObject_1.filterObject)(parsed, Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key)));
            return objectLike.json(parsedWithoutAddedProperties, opts);
        },
        getType: () => objectLike.getType(),
    };
    return {
        ...objectSchema,
        ...(0, schema_utils_1.getSchemaUtils)(objectSchema),
        ...getObjectLikeUtils(objectSchema),
    };
}
exports.withParsedProperties = withParsedProperties;
",
                            "name": "getObjectLikeUtils.js",
                            "type": "file",
                          },
                          {
                            "contents": "export { getObjectLikeUtils, withParsedProperties } from "./getObjectLikeUtils";
export { type ObjectLikeSchema, type ObjectLikeUtils } from "./types";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withParsedProperties = exports.getObjectLikeUtils = void 0;
var getObjectLikeUtils_1 = require("./getObjectLikeUtils");
Object.defineProperty(exports, "getObjectLikeUtils", { enumerable: true, get: function () { return getObjectLikeUtils_1.getObjectLikeUtils; } });
Object.defineProperty(exports, "withParsedProperties", { enumerable: true, get: function () { return getObjectLikeUtils_1.withParsedProperties; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { BaseSchema, Schema } from "../../Schema";
export declare type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> & BaseSchema<Raw, Parsed> & ObjectLikeUtils<Raw, Parsed>;
export interface ObjectLikeUtils<Raw, Parsed> {
    withParsedProperties: <T extends Record<string, any>>(properties: {
        [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
    }) => ObjectLikeSchema<Raw, Parsed & T>;
}
",
                            "name": "types.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
",
                            "name": "types.js",
                            "type": "file",
                          },
                        ],
                        "name": "object-like",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "export declare const any: () => import("../../Schema").Schema<any, any>;
",
                            "name": "any.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.any = void 0;
const Schema_1 = require("../../Schema");
const createIdentitySchemaCreator_1 = require("../../utils/createIdentitySchemaCreator");
exports.any = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ANY, (value) => ({ ok: true, value }));
",
                            "name": "any.js",
                            "type": "file",
                          },
                          {
                            "contents": "export declare const boolean: () => import("../../Schema").Schema<boolean, boolean>;
",
                            "name": "boolean.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.boolean = void 0;
const Schema_1 = require("../../Schema");
const createIdentitySchemaCreator_1 = require("../../utils/createIdentitySchemaCreator");
exports.boolean = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.BOOLEAN, (value) => {
    if (typeof value === "boolean") {
        return {
            ok: true,
            value,
        };
    }
    else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: "Not a boolean",
                },
            ],
        };
    }
});
",
                            "name": "boolean.js",
                            "type": "file",
                          },
                          {
                            "contents": "export { any } from "./any";
export { boolean } from "./boolean";
export { number } from "./number";
export { string } from "./string";
export { unknown } from "./unknown";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unknown = exports.string = exports.number = exports.boolean = exports.any = void 0;
var any_1 = require("./any");
Object.defineProperty(exports, "any", { enumerable: true, get: function () { return any_1.any; } });
var boolean_1 = require("./boolean");
Object.defineProperty(exports, "boolean", { enumerable: true, get: function () { return boolean_1.boolean; } });
var number_1 = require("./number");
Object.defineProperty(exports, "number", { enumerable: true, get: function () { return number_1.number; } });
var string_1 = require("./string");
Object.defineProperty(exports, "string", { enumerable: true, get: function () { return string_1.string; } });
var unknown_1 = require("./unknown");
Object.defineProperty(exports, "unknown", { enumerable: true, get: function () { return unknown_1.unknown; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                          {
                            "contents": "export declare const number: () => import("../../Schema").Schema<number, number>;
",
                            "name": "number.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.number = void 0;
const Schema_1 = require("../../Schema");
const createIdentitySchemaCreator_1 = require("../../utils/createIdentitySchemaCreator");
exports.number = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.NUMBER, (value) => {
    if (typeof value === "number") {
        return {
            ok: true,
            value,
        };
    }
    else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: "Not a number",
                },
            ],
        };
    }
});
",
                            "name": "number.js",
                            "type": "file",
                          },
                          {
                            "contents": "export declare const string: () => import("../../Schema").Schema<string, string>;
",
                            "name": "string.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.string = void 0;
const Schema_1 = require("../../Schema");
const createIdentitySchemaCreator_1 = require("../../utils/createIdentitySchemaCreator");
exports.string = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING, (value) => {
    if (typeof value === "string") {
        return {
            ok: true,
            value,
        };
    }
    else {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: "Not a string",
                },
            ],
        };
    }
});
",
                            "name": "string.js",
                            "type": "file",
                          },
                          {
                            "contents": "export declare const unknown: () => import("../../Schema").Schema<unknown, unknown>;
",
                            "name": "unknown.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unknown = void 0;
const Schema_1 = require("../../Schema");
const createIdentitySchemaCreator_1 = require("../../utils/createIdentitySchemaCreator");
exports.unknown = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.UNKNOWN, (value) => ({ ok: true, value }));
",
                            "name": "unknown.js",
                            "type": "file",
                          },
                        ],
                        "name": "primitives",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "export { record } from "./record";
export { type BaseRecordSchema, type RecordSchema } from "./types";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.record = void 0;
var record_1 = require("./record");
Object.defineProperty(exports, "record", { enumerable: true, get: function () { return record_1.record; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { Schema } from "../../Schema";
import { RecordSchema } from "./types";
export declare function record<RawKey extends string | number, RawValue, ParsedValue, ParsedKey extends string | number>(keySchema: Schema<RawKey, ParsedKey>, valueSchema: Schema<RawValue, ParsedValue>): RecordSchema<RawKey, RawValue, ParsedKey, ParsedValue>;
",
                            "name": "record.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.record = void 0;
const Schema_1 = require("../../Schema");
const entries_1 = require("../../utils/entries");
const isPlainObject_1 = require("../../utils/isPlainObject");
const schema_utils_1 = require("../schema-utils");
function record(keySchema, valueSchema) {
    const baseSchema = {
        parse: async (raw, opts) => {
            return validateAndTransformRecord({
                value: raw,
                isKeyNumeric: (await keySchema.getType()) === Schema_1.SchemaType.NUMBER,
                transformKey: (key) => keySchema.parse(key, opts),
                transformValue: (value) => valueSchema.parse(value, opts),
            });
        },
        json: async (parsed, opts) => {
            return validateAndTransformRecord({
                value: parsed,
                isKeyNumeric: (await keySchema.getType()) === Schema_1.SchemaType.NUMBER,
                transformKey: (key) => keySchema.json(key, opts),
                transformValue: (value) => valueSchema.json(value, opts),
            });
        },
        getType: () => Schema_1.SchemaType.RECORD,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
    };
}
exports.record = record;
async function validateAndTransformRecord({ value, isKeyNumeric, transformKey, transformValue, }) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: isPlainObject_1.NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }
    return (0, entries_1.entries)(value).reduce(async (accPromise, [stringKey, value]) => {
        // skip nullish keys
        if (value == null) {
            return accPromise;
        }
        const acc = await accPromise;
        let key = stringKey;
        if (isKeyNumeric) {
            const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
            if (!isNaN(numberKey)) {
                key = numberKey;
            }
        }
        const transformedKey = await transformKey(key);
        const transformedValue = await transformValue(value);
        if (acc.ok && transformedKey.ok && transformedValue.ok) {
            return {
                ok: true,
                value: {
                    ...acc.value,
                    [transformedKey.value]: transformedValue.value,
                },
            };
        }
        const errors = [];
        if (!acc.ok) {
            errors.push(...acc.errors);
        }
        if (!transformedKey.ok) {
            errors.push(...transformedKey.errors.map((error) => ({
                path: [\`\${key} (key)\`, ...error.path],
                message: error.message,
            })));
        }
        if (!transformedValue.ok) {
            errors.push(...transformedValue.errors.map((error) => ({
                path: [stringKey, ...error.path],
                message: error.message,
            })));
        }
        return {
            ok: false,
            errors,
        };
    }, Promise.resolve({ ok: true, value: {} }));
}
",
                            "name": "record.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { BaseSchema } from "../../Schema";
import { OptionalRecord } from "../../utils/OptionalRecord";
import { SchemaUtils } from "../schema-utils";
export declare type RecordSchema<RawKey extends string | number, RawValue, ParsedKey extends string | number, ParsedValue> = BaseRecordSchema<RawKey, RawValue, ParsedKey, ParsedValue> & SchemaUtils<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;
export declare type BaseRecordSchema<RawKey extends string | number, RawValue, ParsedKey extends string | number, ParsedValue> = BaseSchema<OptionalRecord<RawKey, RawValue>, OptionalRecord<ParsedKey, ParsedValue>>;
",
                            "name": "types.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
",
                            "name": "types.js",
                            "type": "file",
                          },
                        ],
                        "name": "record",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "import { ValidationError } from "../../Schema";
export declare class JsonError extends Error {
    readonly errors: ValidationError[];
    constructor(errors: ValidationError[]);
}
",
                            "name": "JsonError.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonError = void 0;
const stringifyValidationErrors_1 = require("./stringifyValidationErrors");
class JsonError extends Error {
    errors;
    constructor(errors) {
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join("; "));
        this.errors = errors;
        Object.setPrototypeOf(this, JsonError.prototype);
    }
}
exports.JsonError = JsonError;
",
                            "name": "JsonError.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { ValidationError } from "../../Schema";
export declare class ParseError extends Error {
    readonly errors: ValidationError[];
    constructor(errors: ValidationError[]);
}
",
                            "name": "ParseError.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParseError = void 0;
const stringifyValidationErrors_1 = require("./stringifyValidationErrors");
class ParseError extends Error {
    errors;
    constructor(errors) {
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join("; "));
        this.errors = errors;
        Object.setPrototypeOf(this, ParseError.prototype);
    }
}
exports.ParseError = ParseError;
",
                            "name": "ParseError.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { BaseSchema, Schema, SchemaOptions } from "../../Schema";
export interface SchemaUtils<Raw, Parsed> {
    optional: () => Schema<Raw | null | undefined, Parsed | undefined>;
    transform: <Transformed>(transformer: SchemaTransformer<Parsed, Transformed>) => Schema<Raw, Transformed>;
    parseOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Parsed>;
    jsonOrThrow: (raw: unknown, opts?: SchemaOptions) => Promise<Raw>;
}
export interface SchemaTransformer<Parsed, Transformed> {
    transform: (parsed: Parsed) => Transformed;
    untransform: (transformed: any) => Parsed;
}
export declare function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed>;
/**
 * schema utils are defined in one file to resolve issues with circular imports
 */
export declare function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): Schema<Raw | null | undefined, Parsed | undefined>;
export declare function transform<Raw, Parsed, Transformed>(schema: BaseSchema<Raw, Parsed>, transformer: SchemaTransformer<Parsed, Transformed>): Schema<Raw, Transformed>;
",
                            "name": "getSchemaUtils.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = exports.optional = exports.getSchemaUtils = void 0;
const Schema_1 = require("../../Schema");
const JsonError_1 = require("./JsonError");
const ParseError_1 = require("./ParseError");
function getSchemaUtils(schema) {
    return {
        optional: () => optional(schema),
        transform: (transformer) => transform(schema, transformer),
        parseOrThrow: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (parsed.ok) {
                return parsed.value;
            }
            throw new ParseError_1.ParseError(parsed.errors);
        },
        jsonOrThrow: async (parsed, opts) => {
            const raw = await schema.json(parsed, opts);
            if (raw.ok) {
                return raw.value;
            }
            throw new JsonError_1.JsonError(raw.errors);
        },
    };
}
exports.getSchemaUtils = getSchemaUtils;
/**
 * schema utils are defined in one file to resolve issues with circular imports
 */
function optional(schema) {
    const baseSchema = {
        parse: (raw, opts) => {
            if (raw == null) {
                return {
                    ok: true,
                    value: undefined,
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts) => {
            if (parsed == null) {
                return {
                    ok: true,
                    value: null,
                };
            }
            return schema.json(parsed, opts);
        },
        getType: () => Schema_1.SchemaType.OPTIONAL,
    };
    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
exports.optional = optional;
function transform(schema, transformer) {
    const baseSchema = {
        parse: async (raw, opts) => {
            const parsed = await schema.parse(raw, opts);
            if (!parsed.ok) {
                return parsed;
            }
            return {
                ok: true,
                value: transformer.transform(parsed.value),
            };
        },
        json: async (transformed, opts) => {
            const parsed = await transformer.untransform(transformed);
            return schema.json(parsed, opts);
        },
        getType: () => schema.getType(),
    };
    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
exports.transform = transform;
",
                            "name": "getSchemaUtils.js",
                            "type": "file",
                          },
                          {
                            "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from "./getSchemaUtils";
export { JsonError } from "./JsonError";
export { ParseError } from "./ParseError";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParseError = exports.JsonError = exports.transform = exports.optional = exports.getSchemaUtils = void 0;
var getSchemaUtils_1 = require("./getSchemaUtils");
Object.defineProperty(exports, "getSchemaUtils", { enumerable: true, get: function () { return getSchemaUtils_1.getSchemaUtils; } });
Object.defineProperty(exports, "optional", { enumerable: true, get: function () { return getSchemaUtils_1.optional; } });
Object.defineProperty(exports, "transform", { enumerable: true, get: function () { return getSchemaUtils_1.transform; } });
var JsonError_1 = require("./JsonError");
Object.defineProperty(exports, "JsonError", { enumerable: true, get: function () { return JsonError_1.JsonError; } });
var ParseError_1 = require("./ParseError");
Object.defineProperty(exports, "ParseError", { enumerable: true, get: function () { return ParseError_1.ParseError; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { ValidationError } from "../../Schema";
export declare function stringifyValidationError(error: ValidationError): string;
",
                            "name": "stringifyValidationErrors.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifyValidationError = void 0;
function stringifyValidationError(error) {
    if (error.path.length === 0) {
        return error.message;
    }
    return \`\${error.path.join(" -> ")}: \${error.message}\`;
}
exports.stringifyValidationError = stringifyValidationError;
",
                            "name": "stringifyValidationErrors.js",
                            "type": "file",
                          },
                        ],
                        "name": "schema-utils",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "export { set } from "./set";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.set = void 0;
var set_1 = require("./set");
Object.defineProperty(exports, "set", { enumerable: true, get: function () { return set_1.set; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { Schema } from "../../Schema";
export declare function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>>;
",
                            "name": "set.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.set = void 0;
const Schema_1 = require("../../Schema");
const list_1 = require("../list");
const schema_utils_1 = require("../schema-utils");
function set(schema) {
    const listSchema = (0, list_1.list)(schema);
    const baseSchema = {
        parse: async (raw, opts) => {
            const parsedList = await listSchema.parse(raw, opts);
            if (parsedList.ok) {
                return {
                    ok: true,
                    value: new Set(parsedList.value),
                };
            }
            else {
                return parsedList;
            }
        },
        json: async (parsed, opts) => {
            if (!(parsed instanceof Set)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: [],
                            message: "Not a Set",
                        },
                    ],
                };
            }
            const jsonList = await listSchema.json([...parsed], opts);
            return jsonList;
        },
        getType: () => Schema_1.SchemaType.SET,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
    };
}
exports.set = set;
",
                            "name": "set.js",
                            "type": "file",
                          },
                        ],
                        "name": "set",
                        "type": "directory",
                      },
                      {
                        "contents": [
                          {
                            "contents": "export declare function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(parsedDiscriminant: ParsedDiscriminant, rawDiscriminant: RawDiscriminant): Discriminant<RawDiscriminant, ParsedDiscriminant>;
export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
    parsedDiscriminant: ParsedDiscriminant;
    rawDiscriminant: RawDiscriminant;
}
",
                            "name": "discriminant.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.discriminant = void 0;
function discriminant(parsedDiscriminant, rawDiscriminant) {
    return {
        parsedDiscriminant,
        rawDiscriminant,
    };
}
exports.discriminant = discriminant;
",
                            "name": "discriminant.js",
                            "type": "file",
                          },
                          {
                            "contents": "export { discriminant, type Discriminant } from "./discriminant";
export { type inferParsedDiscriminant, type inferParsedUnion, type inferRawDiscriminant, type inferRawUnion, type UnionSubtypes, } from "./types";
export { union } from "./union";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.union = exports.discriminant = void 0;
var discriminant_1 = require("./discriminant");
Object.defineProperty(exports, "discriminant", { enumerable: true, get: function () { return discriminant_1.discriminant; } });
var union_1 = require("./union");
Object.defineProperty(exports, "union", { enumerable: true, get: function () { return union_1.union; } });
",
                            "name": "index.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from "../object";
import { Discriminant } from "./discriminant";
export declare type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
};
export declare type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];
export declare type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];
export declare type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string ? D : D extends Discriminant<infer Raw, any> ? Raw : never;
export declare type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string ? D : D extends Discriminant<any, infer Parsed> ? Parsed : never;
",
                            "name": "types.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
",
                            "name": "types.js",
                            "type": "file",
                          },
                          {
                            "contents": "import { ObjectLikeSchema } from "../object-like";
import { Discriminant } from "./discriminant";
import { inferParsedUnion, inferRawUnion, UnionSubtypes } from "./types";
export declare function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(discriminant: D, union: U): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>>;
",
                            "name": "union.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.union = void 0;
const Schema_1 = require("../../Schema");
const isPlainObject_1 = require("../../utils/isPlainObject");
const keys_1 = require("../../utils/keys");
const enum_1 = require("../enum");
const object_like_1 = require("../object-like");
const schema_utils_1 = require("../schema-utils");
function union(discriminant, union) {
    const rawDiscriminant = typeof discriminant === "string" ? discriminant : discriminant.rawDiscriminant;
    const parsedDiscriminant = typeof discriminant === "string"
        ? discriminant
        : discriminant.parsedDiscriminant;
    const discriminantValueSchema = (0, enum_1.enum_)((0, keys_1.keys)(union));
    const baseSchema = {
        parse: async (raw, opts) => {
            return transformAndValidateUnion(raw, rawDiscriminant, parsedDiscriminant, (discriminantValue) => discriminantValueSchema.parse(discriminantValue, opts), (discriminantValue) => union[discriminantValue], opts?.allowUnknownKeys ?? false, (additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.parse(additionalProperties, opts));
        },
        json: async (parsed, opts) => {
            return transformAndValidateUnion(parsed, parsedDiscriminant, rawDiscriminant, (discriminantValue) => discriminantValueSchema.json(discriminantValue, opts), (discriminantValue) => union[discriminantValue], opts?.allowUnknownKeys ?? false, (additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.json(additionalProperties, opts));
        },
        getType: () => Schema_1.SchemaType.UNION,
    };
    return {
        ...baseSchema,
        ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
        ...(0, object_like_1.getObjectLikeUtils)(baseSchema),
    };
}
exports.union = union;
async function transformAndValidateUnion(value, discriminant, transformedDiscriminant, transformDiscriminantValue, getAdditionalPropertiesSchema, allowUnknownKeys, transformAdditionalProperties) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: isPlainObject_1.NOT_AN_OBJECT_ERROR_MESSAGE,
                },
            ],
        };
    }
    const { [discriminant]: discriminantValue, ...additionalProperties } = value;
    if (discriminantValue == null) {
        return {
            ok: false,
            errors: [
                {
                    path: [],
                    message: \`Missing discriminant ("\${discriminant}")\`,
                },
            ],
        };
    }
    const transformedDiscriminantValue = await transformDiscriminantValue(discriminantValue);
    if (!transformedDiscriminantValue.ok) {
        return {
            ok: false,
            errors: transformedDiscriminantValue.errors.map((error) => ({
                path: [discriminant, ...error.path],
                message: error.message,
            })),
        };
    }
    const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);
    if (additionalPropertiesSchema == null) {
        if (allowUnknownKeys) {
            return {
                ok: true,
                value: {
                    [transformedDiscriminant]: transformedDiscriminantValue.value,
                    ...additionalProperties,
                },
            };
        }
        else {
            return {
                ok: false,
                errors: [
                    {
                        path: [discriminant],
                        message: "Unrecognized discriminant value",
                    },
                ],
            };
        }
    }
    const transformedAdditionalProperties = await transformAdditionalProperties(additionalProperties, additionalPropertiesSchema);
    if (!transformedAdditionalProperties.ok) {
        return transformedAdditionalProperties;
    }
    return {
        ok: true,
        value: {
            [transformedDiscriminant]: discriminantValue,
            ...transformedAdditionalProperties.value,
        },
    };
}
",
                            "name": "union.js",
                            "type": "file",
                          },
                        ],
                        "name": "union",
                        "type": "directory",
                      },
                    ],
                    "name": "builders",
                    "type": "directory",
                  },
                  {
                    "contents": "export * from "./builders";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from "./Schema";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  {
                    "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./builders"), exports);
",
                    "name": "index.js",
                    "type": "file",
                  },
                  {
                    "contents": [
                      {
                        "contents": "export declare type MaybePromise<T> = T | Promise<T>;
",
                        "name": "MaybePromise.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
",
                        "name": "MaybePromise.js",
                        "type": "file",
                      },
                      {
                        "contents": "export declare type OptionalRecord<K extends string | number, V> = Record<K, V | undefined>;
",
                        "name": "OptionalRecord.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
",
                        "name": "OptionalRecord.js",
                        "type": "file",
                      },
                      {
                        "contents": "export declare type addQuestionMarksToNullableProperties<T> = {
    [K in OptionalKeys<T>]?: T[K];
} & Pick<T, RequiredKeys<T>>;
export declare type OptionalKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? K : null extends T[K] ? K : never;
}[keyof T];
export declare type RequiredKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? never : null extends T[K] ? never : K;
}[keyof T];
",
                        "name": "addQuestionMarksToNullableProperties.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
",
                        "name": "addQuestionMarksToNullableProperties.js",
                        "type": "file",
                      },
                      {
                        "contents": "import { MaybeValid, Schema, SchemaOptions, SchemaType } from "../Schema";
export declare function createIdentitySchemaCreator<T>(schemaType: SchemaType, validate: (value: unknown, opts?: SchemaOptions) => MaybeValid<T>): () => Schema<T, T>;
",
                        "name": "createIdentitySchemaCreator.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIdentitySchemaCreator = void 0;
const schema_utils_1 = require("../builders/schema-utils");
function createIdentitySchemaCreator(schemaType, validate) {
    return () => {
        const baseSchema = {
            parse: validate,
            json: validate,
            getType: () => schemaType,
        };
        return {
            ...baseSchema,
            ...(0, schema_utils_1.getSchemaUtils)(baseSchema),
        };
    };
}
exports.createIdentitySchemaCreator = createIdentitySchemaCreator;
",
                        "name": "createIdentitySchemaCreator.js",
                        "type": "file",
                      },
                      {
                        "contents": "export declare function entries<T>(object: T): [keyof T, T[keyof T]][];
",
                        "name": "entries.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.entries = void 0;
function entries(object) {
    return Object.entries(object);
}
exports.entries = entries;
",
                        "name": "entries.js",
                        "type": "file",
                      },
                      {
                        "contents": "export declare function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K>;
",
                        "name": "filterObject.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterObject = void 0;
function filterObject(obj, keysToInclude) {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (keysToIncludeSet.has(key)) {
            acc[key] = value;
        }
        return acc;
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    }, {});
}
exports.filterObject = filterObject;
",
                        "name": "filterObject.js",
                        "type": "file",
                      },
                      {
                        "contents": "export declare const NOT_AN_OBJECT_ERROR_MESSAGE = "Not an object";
export declare function isPlainObject(value: unknown): value is Record<string, unknown>;
",
                        "name": "isPlainObject.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPlainObject = exports.NOT_AN_OBJECT_ERROR_MESSAGE = void 0;
exports.NOT_AN_OBJECT_ERROR_MESSAGE = "Not an object";
// borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
        return false;
    }
    if (Object.getPrototypeOf(value) === null) {
        return true;
    }
    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
}
exports.isPlainObject = isPlainObject;
",
                        "name": "isPlainObject.js",
                        "type": "file",
                      },
                      {
                        "contents": "export declare function keys<T>(object: T): (keyof T)[];
",
                        "name": "keys.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.keys = void 0;
function keys(object) {
    return Object.keys(object);
}
exports.keys = keys;
",
                        "name": "keys.js",
                        "type": "file",
                      },
                      {
                        "contents": "export declare function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]];
",
                        "name": "partition.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.partition = void 0;
function partition(items, predicate) {
    const trueItems = [], falseItems = [];
    for (const item of items) {
        if (predicate(item)) {
            trueItems.push(item);
        }
        else {
            falseItems.push(item);
        }
    }
    return [trueItems, falseItems];
}
exports.partition = partition;
",
                        "name": "partition.js",
                        "type": "file",
                      },
                    ],
                    "name": "utils",
                    "type": "directory",
                  },
                ],
                "name": "schemas",
                "type": "directory",
              },
            ],
            "name": "core",
            "type": "directory",
          },
          {
            "contents": [
              {
                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
export declare class FernApiError extends Error {
    readonly statusCode?: number;
    readonly body?: unknown;
    constructor({ message, statusCode, body }: {
        message?: string;
        statusCode?: number;
        body?: unknown;
    });
}
",
                "name": "FernApiError.d.ts",
                "type": "file",
              },
              {
                "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FernApiError = void 0;
class FernApiError extends Error {
    statusCode;
    body;
    constructor({ message, statusCode, body }) {
        super(message);
        Object.setPrototypeOf(this, FernApiError.prototype);
        if (statusCode != null) {
            this.statusCode = statusCode;
        }
        if (body !== undefined) {
            this.body = body;
        }
    }
}
exports.FernApiError = FernApiError;
",
                "name": "FernApiError.js",
                "type": "file",
              },
              {
                "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
export declare class FernApiTimeoutError extends Error {
    constructor();
}
",
                "name": "FernApiTimeoutError.d.ts",
                "type": "file",
              },
              {
                "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FernApiTimeoutError = void 0;
class FernApiTimeoutError extends Error {
    constructor() {
        super("Timeout");
        Object.setPrototypeOf(this, FernApiTimeoutError.prototype);
    }
}
exports.FernApiTimeoutError = FernApiTimeoutError;
",
                "name": "FernApiTimeoutError.js",
                "type": "file",
              },
              {
                "contents": "export { FernApiError } from "./FernApiError";
export { FernApiTimeoutError } from "./FernApiTimeoutError";
",
                "name": "index.d.ts",
                "type": "file",
              },
              {
                "contents": ""use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FernApiTimeoutError = exports.FernApiError = void 0;
var FernApiError_1 = require("./FernApiError");
Object.defineProperty(exports, "FernApiError", { enumerable: true, get: function () { return FernApiError_1.FernApiError; } });
var FernApiTimeoutError_1 = require("./FernApiTimeoutError");
Object.defineProperty(exports, "FernApiTimeoutError", { enumerable: true, get: function () { return FernApiTimeoutError_1.FernApiTimeoutError; } });
",
                "name": "index.js",
                "type": "file",
              },
            ],
            "name": "errors",
            "type": "directory",
          },
          {
            "contents": "export * as FernApi from "./api";
export { FernApiClient } from "./Client";
export { FernApiError, FernApiTimeoutError } from "./errors";
",
            "name": "index.d.ts",
            "type": "file",
          },
          {
            "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FernApiTimeoutError = exports.FernApiError = exports.FernApiClient = exports.FernApi = void 0;
exports.FernApi = __importStar(require("./api"));
var Client_1 = require("./Client");
Object.defineProperty(exports, "FernApiClient", { enumerable: true, get: function () { return Client_1.FernApiClient; } });
var errors_1 = require("./errors");
Object.defineProperty(exports, "FernApiError", { enumerable: true, get: function () { return errors_1.FernApiError; } });
Object.defineProperty(exports, "FernApiTimeoutError", { enumerable: true, get: function () { return errors_1.FernApiTimeoutError; } });
",
            "name": "index.js",
            "type": "file",
          },
          {
            "contents": [
              {
                "contents": "export * from "./resources";
",
                "name": "index.d.ts",
                "type": "file",
              },
              {
                "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./resources"), exports);
",
                "name": "index.js",
                "type": "file",
              },
              {
                "contents": [
                  {
                    "contents": [
                      {
                        "contents": "export * from "./types";
",
                        "name": "index.d.ts",
                        "type": "file",
                      },
                      {
                        "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./types"), exports);
",
                        "name": "index.js",
                        "type": "file",
                      },
                      {
                        "contents": [
                          {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as serializers from "../../..";
import { FernApi } from "../../../..";
import * as core from "../../../../core";
export declare const CreateMovieRequest: core.serialization.ObjectSchema<serializers.CreateMovieRequest.Raw, FernApi.CreateMovieRequest>;
export declare namespace CreateMovieRequest {
    interface Raw {
        title: string;
        rating: number;
    }
}
",
                            "name": "CreateMovieRequest.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateMovieRequest = void 0;
const core = __importStar(require("../../../../core"));
exports.CreateMovieRequest = core.serialization.object({
    title: core.serialization.string(),
    rating: core.serialization.number(),
});
",
                            "name": "CreateMovieRequest.js",
                            "type": "file",
                          },
                          {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as serializers from "../../..";
import { FernApi } from "../../../..";
import * as core from "../../../../core";
export declare const Movie: core.serialization.ObjectSchema<serializers.Movie.Raw, FernApi.Movie>;
export declare namespace Movie {
    interface Raw {
        id: serializers.MovieId.Raw;
        title: string;
        rating: number;
    }
}
",
                            "name": "Movie.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Movie = void 0;
const core = __importStar(require("../../../../core"));
exports.Movie = core.serialization.object({
    id: core.serialization.lazy(async () => (await Promise.resolve().then(() => __importStar(require("../../..")))).MovieId),
    title: core.serialization.string(),
    rating: core.serialization.number(),
});
",
                            "name": "Movie.js",
                            "type": "file",
                          },
                          {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as serializers from "../../..";
import { FernApi } from "../../../..";
import * as core from "../../../../core";
export declare const MovieId: core.serialization.Schema<serializers.MovieId.Raw, FernApi.MovieId>;
export declare namespace MovieId {
    type Raw = string;
}
",
                            "name": "MovieId.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MovieId = void 0;
const core = __importStar(require("../../../../core"));
exports.MovieId = core.serialization.string();
",
                            "name": "MovieId.js",
                            "type": "file",
                          },
                          {
                            "contents": "export * from "./MovieId";
export * from "./Movie";
export * from "./CreateMovieRequest";
",
                            "name": "index.d.ts",
                            "type": "file",
                          },
                          {
                            "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./MovieId"), exports);
__exportStar(require("./Movie"), exports);
__exportStar(require("./CreateMovieRequest"), exports);
",
                            "name": "index.js",
                            "type": "file",
                          },
                        ],
                        "name": "types",
                        "type": "directory",
                      },
                    ],
                    "name": "imdb",
                    "type": "directory",
                  },
                  {
                    "contents": "export * as imdb from "./imdb";
export * from "./imdb/types";
",
                    "name": "index.d.ts",
                    "type": "file",
                  },
                  {
                    "contents": ""use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.imdb = void 0;
exports.imdb = __importStar(require("./imdb"));
__exportStar(require("./imdb/types"), exports);
",
                    "name": "index.js",
                    "type": "file",
                  },
                ],
                "name": "resources",
                "type": "directory",
              },
            ],
            "name": "serialization",
            "type": "directory",
          },
        ],
        "name": "typescript",
        "type": "directory",
      },
    ],
    "name": "generated",
    "type": "directory",
  },
]
`;
