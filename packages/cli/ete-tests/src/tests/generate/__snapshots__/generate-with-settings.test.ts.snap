// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`fern generate with settings > single api 1`] = `
[
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

from .error import Error
from .file import File
from .prediction import Prediction
from .results import Results
from .source import Source
from .source_file import SourceFile
from .source_result import SourceResult
from .source_url import SourceUrl
from .url import Url

__all__ = ["Error", "File", "Prediction", "Results", "Source", "SourceFile", "SourceResult", "SourceUrl", "Url"]
",
    "name": "__init__.py",
    "type": "file",
  },
  {
    "contents": [
      {
        "contents": "# This file was auto-generated by Fern from our API Definition.

from .datetime_utils import serialize_datetime
from .pydantic_utilities import (
    IS_PYDANTIC_V2,
    UniversalBaseModel,
    UniversalRootModel,
    deep_union_pydantic_dicts,
    parse_obj_as,
    universal_field_validator,
    universal_root_validator,
    update_forward_refs,
)

__all__ = [
    "IS_PYDANTIC_V2",
    "UniversalBaseModel",
    "UniversalRootModel",
    "deep_union_pydantic_dicts",
    "parse_obj_as",
    "serialize_datetime",
    "universal_field_validator",
    "universal_root_validator",
    "update_forward_refs",
]
",
        "name": "__init__.py",
        "type": "file",
      },
      {
        "contents": "# This file was auto-generated by Fern from our API Definition.

import datetime as dt


def serialize_datetime(v: dt.datetime) -> str:
    """
    Serialize a datetime including timezone info.

    Uses the timezone info provided if present, otherwise uses the current runtime's timezone info.

    UTC datetimes end in "Z" while all other timezones are represented as offset from UTC, e.g. +05:00.
    """

    def _serialize_zoned_datetime(v: dt.datetime) -> str:
        if v.tzinfo is not None and v.tzinfo.tzname(None) == dt.timezone.utc.tzname(None):
            # UTC is a special case where we use "Z" at the end instead of "+00:00"
            return v.isoformat().replace("+00:00", "Z")
        else:
            # Delegate to the typical +/- offset format
            return v.isoformat()

    if v.tzinfo is not None:
        return _serialize_zoned_datetime(v)
    else:
        local_tz = dt.datetime.now().astimezone().tzinfo
        localized_dt = v.replace(tzinfo=local_tz)
        return _serialize_zoned_datetime(localized_dt)
",
        "name": "datetime_utils.py",
        "type": "file",
      },
      {
        "contents": "# This file was auto-generated by Fern from our API Definition.

# nopycln: file
import datetime as dt
import typing
from collections import defaultdict
from functools import wraps

import pydantic

from .datetime_utils import serialize_datetime

IS_PYDANTIC_V2 = pydantic.VERSION.startswith("2.")

if IS_PYDANTIC_V2:
    # isort will try to reformat the comments on these imports, which breaks mypy
    # isort: off
    from pydantic.v1.datetime_parse import (  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
        parse_date as parse_date,
    )
    from pydantic.v1.datetime_parse import (  # pyright: ignore[reportMissingImports] # Pydantic v2
        parse_datetime as parse_datetime,
    )
    from pydantic.v1.json import (  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
        ENCODERS_BY_TYPE as encoders_by_type,
    )
    from pydantic.v1.typing import (  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
        get_args as get_args,
    )
    from pydantic.v1.typing import get_origin as get_origin  # pyright: ignore[reportMissingImports] # Pydantic v2
    from pydantic.v1.typing import (  # pyright: ignore[reportMissingImports] # Pydantic v2
        is_literal_type as is_literal_type,
    )
    from pydantic.v1.typing import is_union as is_union  # pyright: ignore[reportMissingImports] # Pydantic v2
    from pydantic.v1.fields import ModelField as ModelField  # type: ignore # pyright: ignore[reportMissingImports] # Pydantic v2
else:
    from pydantic.datetime_parse import parse_date as parse_date  # type: ignore # Pydantic v1
    from pydantic.datetime_parse import parse_datetime as parse_datetime  # type: ignore # Pydantic v1
    from pydantic.fields import ModelField as ModelField  # type: ignore # Pydantic v1
    from pydantic.json import ENCODERS_BY_TYPE as encoders_by_type  # type: ignore # Pydantic v1
    from pydantic.typing import get_args as get_args  # type: ignore # Pydantic v1
    from pydantic.typing import get_origin as get_origin  # type: ignore # Pydantic v1
    from pydantic.typing import is_literal_type as is_literal_type  # type: ignore # Pydantic v1
    from pydantic.typing import is_union as is_union  # type: ignore # Pydantic v1

    # isort: on


T = typing.TypeVar("T")
Model = typing.TypeVar("Model", bound=pydantic.BaseModel)


def deep_union_pydantic_dicts(
    source: typing.Dict[str, typing.Any], destination: typing.Dict[str, typing.Any]
) -> typing.Dict[str, typing.Any]:
    for key, value in source.items():
        if isinstance(value, dict):
            node = destination.setdefault(key, {})
            deep_union_pydantic_dicts(value, node)
        else:
            destination[key] = value

    return destination


def parse_obj_as(type_: typing.Type[T], object_: typing.Any) -> T:
    if IS_PYDANTIC_V2:
        adapter = pydantic.TypeAdapter(type_)  # type: ignore # Pydantic v2
        return adapter.validate_python(object_)
    else:
        return pydantic.parse_obj_as(type_, object_)


def to_jsonable_with_fallback(
    obj: typing.Any, fallback_serializer: typing.Callable[[typing.Any], typing.Any]
) -> typing.Any:
    if IS_PYDANTIC_V2:
        from pydantic_core import to_jsonable_python

        return to_jsonable_python(obj, fallback=fallback_serializer)
    else:
        return fallback_serializer(obj)


class UniversalBaseModel(pydantic.BaseModel):
    class Config:
        populate_by_name = True
        smart_union = True
        allow_population_by_field_name = True
        json_encoders = {dt.datetime: serialize_datetime}

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        if IS_PYDANTIC_V2:
            return super().model_dump_json(**kwargs_with_defaults)  # type: ignore # Pydantic v2
        else:
            return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        if IS_PYDANTIC_V2:
            return deep_union_pydantic_dicts(
                super().model_dump(**kwargs_with_defaults_exclude_unset),  # type: ignore # Pydantic v2
                super().model_dump(**kwargs_with_defaults_exclude_none),  # type: ignore # Pydantic v2
            )
        else:
            return deep_union_pydantic_dicts(
                super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
            )


UniversalRootModel: typing.Type[typing.Any]
if IS_PYDANTIC_V2:

    class V2RootModel(UniversalBaseModel, pydantic.RootModel):  # type: ignore # Pydantic v2
        pass

    UniversalRootModel = V2RootModel
else:
    UniversalRootModel = UniversalBaseModel


def encode_by_type(o: typing.Any) -> typing.Any:
    encoders_by_class_tuples: typing.Dict[
        typing.Callable[[typing.Any], typing.Any], typing.Tuple[typing.Any, ...]
    ] = defaultdict(tuple)
    for type_, encoder in encoders_by_type.items():
        encoders_by_class_tuples[encoder] += (type_,)

    if type(o) in encoders_by_type:
        return encoders_by_type[type(o)](o)
    for encoder, classes_tuple in encoders_by_class_tuples.items():
        if isinstance(o, classes_tuple):
            return encoder(o)


def update_forward_refs(model: typing.Type["Model"], **localns: typing.Any) -> None:
    if IS_PYDANTIC_V2:
        model.model_rebuild(force=True)  # type: ignore # Pydantic v2
    else:
        model.update_forward_refs(**localns)


# Mirrors Pydantic's internal typing
AnyCallable = typing.Callable[..., typing.Any]


def universal_root_validator(pre: bool = False) -> typing.Callable[[AnyCallable], AnyCallable]:
    def decorator(func: AnyCallable) -> AnyCallable:
        @wraps(func)
        def validate(*args: typing.Any, **kwargs: typing.Any) -> AnyCallable:
            if IS_PYDANTIC_V2:
                wrapped_func = pydantic.model_validator("before" if pre else "after")(func)  # type: ignore # Pydantic v2
            else:
                wrapped_func = pydantic.root_validator(pre=pre)(func)  # type: ignore # Pydantic v1

            return wrapped_func(*args, **kwargs)

        return validate

    return decorator


def universal_field_validator(field_name: str, pre: bool = False) -> typing.Callable[[AnyCallable], AnyCallable]:
    def decorator(func: AnyCallable) -> AnyCallable:
        @wraps(func)
        def validate(*args: typing.Any, **kwargs: typing.Any) -> AnyCallable:
            if IS_PYDANTIC_V2:
                wrapped_func = pydantic.field_validator(field_name, mode="before" if pre else "after")(func)  # type: ignore # Pydantic v2
            else:
                wrapped_func = pydantic.validator(field_name, pre=pre)(func)

            return wrapped_func(*args, **kwargs)

        return validate

    return decorator
",
        "name": "pydantic_utilities.py",
        "type": "file",
      },
    ],
    "name": "core",
    "type": "directory",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Error(UniversalBaseModel):
    message: str = pydantic.Field()
    """
    An error message.
    """

    file: str = pydantic.Field()
    """
    A file path relative to the top level source URL or file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "error.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class File(UniversalBaseModel):
    filename: typing.Optional[str] = pydantic.Field(default=None)
    """
    The name of the file.
    """

    content_type: typing.Optional[str] = pydantic.Field(default=None)
    """
    The content type of the file.
    """

    md_5_sum: str = pydantic.Field(alias="md5sum")
    """
    The MD5 checksum of the file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "file.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Prediction(UniversalBaseModel):
    file: str = pydantic.Field()
    """
    A file path relative to the top level source URL or file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "prediction.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .error import Error
from .prediction import Prediction


class Results(UniversalBaseModel):
    predictions: typing.List[Prediction]
    errors: typing.List[Error]

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "results.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

from .source_file import SourceFile
from .source_url import SourceUrl

Source = typing.Union[SourceUrl, SourceFile]
",
    "name": "source.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2
from .file import File


class SourceFile(File):
    type: typing.Literal["file"] = "file"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "source_file.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .results import Results
from .source import Source


class SourceResult(UniversalBaseModel):
    source: Source
    results: typing.Optional[Results] = None
    error: typing.Optional[str] = pydantic.Field(default=None)
    """
    An error message.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "source_result.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2
from .url import Url


class SourceUrl(Url):
    type: typing.Literal["url"] = "url"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "source_url.py",
    "type": "file",
  },
  {
    "contents": "# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic

from .core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel


class Url(UniversalBaseModel):
    url: str = pydantic.Field()
    """
    The URL of the source media file.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow")  # type: ignore # Pydantic v2
    else:

        class Config:
            extra = pydantic.Extra.allow
",
    "name": "url.py",
    "type": "file",
  },
]
`;
